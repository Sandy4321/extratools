{
    "docs": [
        {
            "location": "/",
            "text": "Functions:\n\n\n\n\nseqtools\n\n\nsortedtools\n\n\nstrtools\n\n\nrangetools\n\n\ndicttools\n\n\njsontools\n\n\nsettools\n\n\ntabletools\n\n\nmathtools\n\n\nstattools\n\n\nmisctools\n\n\nprinttools\n\n\ndebugtools\n\n\n\n\nData Structures:\n\n\n\n\ndisjointsets\n\n\ndefaultlist\n\n\n\n\nCLI Tools:\n\n\n\n\ndicttools.remap\n\n\njsontools.flatten\n\n\njsontools.teststats",
            "title": "Index"
        },
        {
            "location": "/functions/",
            "text": "Functions\n\n\n\n\nseqtools\n\n\nTools for matching sequences (including strings), without gaps allowed between matching items. Note that empty sequence is always a sub-sequence of any other sequence.\n\n\n\n\nbestsubseq(a, key)\n finds the best sub-sequence of \na\n that maximizes the key function \nkey\n.\n\n\n\n\nbestsubseq([1, -2, 3, -4, 5, -6], sum)\n# [5]\n\n\n\n\n\n\n\n\nfindallsubseqs(a, b, overlap=False)\n returns all the positions where \na\n is a sub-sequence of \nb\n.\n\n\n\n\n\n\nIn default, no overlapping is allowed. You can change the behavior by specify \noverlap\n.\n\n\n\n\n\n\nUnlike other function in \nseqtools\n, nothing is returned when \na\n is empty.\n\n\n\n\n\n\n\n\n\n\nfindsubseq(a, b)\n returns the first position where \na\n is a sub-sequence of \nb\n, or \n-1\n when not found.\n\n\n\n\n\n\nissubseq(a, b)\n checks if \na\n is a sub-sequence of \nb\n.\n\n\n\n\n\n\ncommonsubseq(a, b)\n finds the \nlongest common sub-sequence\n among two sequences \na\n and \nb\n.\n\n\n\n\n\n\ncommonsubseq(\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 1, 1]\n)\n# [0, 1, 1]\n\n\n\n\nTools for matching sequences (including strings), with gaps allowed between matching items. Note that empty sequence is always a sub-sequence of any other sequence.\n\n\n\n\nbestsubseqwithgap(a, key)\n finds the best sub-sequence of \na\n that maximizes the key function \nkey\n, where gaps are allowed.\n\n\n\n\nbestsubseqwithgap([1, -2, 3, -4, 5, -6], sum)\n# [1, 3, 5]\n\n\n\n\n\n\n\n\nfindsubseqwithgap(a, b)\n returns the matching positions where \na\n is a sub-sequence of \nb\n, where gaps are allowed, or \nNone\n when not found.\n\n\n\n\n\n\nissubseqwithgap(a, b)\n checks if \na\n is a sub-sequence of \nb\n, where gaps are allowed.\n\n\n\n\n\n\ncommonsubseqwithgap(a, b)\n finds the \nlongest common sub-sequence\n among two sequences \na\n and \nb\n, where gaps are allowed.\n\n\n\n\n\n\ncommonsubseqwithgap(\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 1, 1]\n)\n# [0, 1, 1, 1]\n\n\n\n\n\n\n\n\nalign(a, b, cost=None, bound=inf, default=None)\n \naligns\n two sequences \na\n and \nb\n, such that the total cost of the aligned sequences given the pair-wise cost function \ncost(x, y)\n is minimized.\n\n\n\n\n\n\nAssume the aligned sequences are \na'\n and \nb'\n. The total cost is \nsum(cost(x, y) for x, y in zip(a', b'))\n.\n\n\n\n\n\n\nBoth the minimum total cost and the respective aligned sequences are returned as a tuple.\n\n\n\n\n\n\nIn default, the cost function \ncost(x, y)\n returns \n1\n when \nx == y\n and \n0\n when not. This is equal to the \nedit distance\n.\n\n\n\n\n\n\nTo speedup the computation, a threshold of maximum cost \nbound=inf\n can be specified. When there is no satisfying result, \nNone\n is returned.\n\n\n\n\n\n\n\n\n\n\nalign(\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 1, 1]\n)\n# (2, ([0, None, 1, 1, 0,    1],\n#      [0, 0,    1, 1, None, 1]))\n\nalign(\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 1, 1],\n    bound=1\n)\n# None\n\n\n\n\nTools for comparing sequences (including strings).\n\n\n\n\n\n\nproductcmp(x, y)\n compares two sequences \nx\n and \ny\n with equal length according to \nproduct order\n. Returns \n-1\n if smaller, \n0\n if equal, \n1\n if greater, and \nNone\n if not comparable.\n\n\n\n\nThrow exception if \nx\n and \ny\n have different lengths.\n\n\n\n\n\n\n\n\nTools for sorting sequences.\n\n\n\n\nsortedbyrank(data, ranks, reverse=False)\n returns the sorted list of \ndata\n, according to the respective rank of each individual element in \nranks\n.\n\n\n\n\nTools for encoding/decoding sequences.\n\n\n\n\n\n\ncompress(data, key=None)\n compresses the sequence by encoding continuous identical \nItem\n to \n(Item, Count)\n, according to \nrun-length encoding\n.\n\n\n\n\nDifferent from \nitertools.compress\n.\n\n\n\n\n\n\n\n\nlist(compress([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]))\n# [(1, 1), (2, 2), (3, 3), (4, 4)]\n\n\n\n\n\n\n\n\ndecompress(data)\n decompresses the sequence by decoding \n(Item, Count)\n to continuous identical \nItem\n, according to \nrun-length encoding\n.\n\n\n\n\n\n\ntodeltas(data, op=operator.sub)\n compresses the sequence by encoding the difference between previous and current items, according to \ndelta encoding\n.\n\n\n\n\nFor custom type of item, either define the \n-\n operator or specify the \nop\n function computing the difference.\n\n\n\n\n\n\n\n\nlist(todeltas([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]))\n# [1, 1, 0, 1, 0, 0, 1, 0, 0, 0]\n\n\n\n\n\n\n\n\nfromdeltas(data, op=operator.add)\n decompresses the sequence by decoding the difference between previous and current items, according to \ndelta encoding\n.\n\n\n\n\nFor custom type of item, either define the \n+\n operator or specify the \nop\n function merging the difference.\n\n\n\n\n\n\n\n\nTools for joining sequences.\n\n\n\n\n\n\njoin(leftseq, rightseq, leftkey=None, rightkey=None, leftdefault=no_default, rightdefault=no_default)\n joins two sequences, optionally according to \nleftkey\n and \nrightkey\n, respectively. Outer join is also supported.\n\n\n\n\n\n\nIf both two sequences are sorted according to \nleftkey\n and \nrightkey\n, respectively, then optimized \nsortedtools.join\n with the same API should be used for better efficiency.\n\n\n\n\n\n\nUnlike \nsortedtools.join\n, \njoin\n is just a wrapper of \ntoolz.itertools.join\n with a slightly more friendly API.\n\n\n\n\n\n\n\n\n\n\n\n\nsortedtools\n\n\nTools for joining sorted sequences.\n\n\n\n\n\n\nsortedjoin(leftseq, rightseq, leftkey=None, rightkey=None, leftdefault=no_default, rightdefault=no_default)\n joins two sequences, optionally according to \nleftkey\n and \nrightkey\n, respectively. Outer join is also supported.\n\n\n\n\n\n\nTwo sequences must be already sorted according to \nleftkey\n and \nrightkey\n, respectively.\n\n\n\n\n\n\nsortedjoin\n is completely lazy, and more efficient than \nseqtools.join\n and its underneath \ntoolz.itertools.join\n.\n\n\n\n\n\n\n\n\n\n\nlist(sortedjoin([-1, -1, -2, -4, -5, -6], [0, 1, 1, 2, 3, 4, 5, 5], leftkey=abs, leftdefault=None))\n# [(None, 0),\n#  (-1, 1),\n#  (-1, 1),\n#  (-1, 1),\n#  (-1, 1),\n#  (-2, 2),\n#  (None, 3),\n#  (-4, 4),\n#  (-5, 5),\n#  (-5, 5)]\n\n\n\n\nTools for matching sorted sequences.\n\n\n\n\n\n\nsortedcommon(a, b, key=None)\n returns the common elements between \na\n and \nb\n.\n\n\n\n\nWhen both \na\n and \nb\n are sorted sets with no duplicate element, equal to \nsorted(set(a) & set(b))\n but more efficient.\n\n\n\n\n\n\n\n\nsortedalone(a, b, key=None)\n returns the elements not in both \na\n and \nb\n.\n\n\n\n\nWhen both \na\n and \nb\n are sorted sets with no duplicate element, equal to \nsorted((set(a) | set(b)) - (set(a) & set(b)))\n but more efficient.\n\n\n\n\n\n\n\n\nsorteddiff(a, b, key=None)\n returns the elements only in \na\n and not in \nb\n.\n\n\n\n\nWhen both \na\n and \nb\n are sorted sets with no duplicate element, equal to \nsorted(set(a) - set(b))\n but more efficient.\n\n\n\n\n\n\n\n\nissubsorted(a, b, key=None)\n checks if \na\n is a sorted sub-sequence of \nb\n.\n\n\n\n\nWhen both \na\n and \nb\n are sorted sets with no duplicate element, equal to \nset(a) <= set(b)\n but more efficient.\n\n\n\n\n\n\n\n\n\n\nstrtools\n\n\nTools for string matching.\n\n\n\n\ncommonsubstr(a, b)\n finds the \nlongest common sub-string\n among two strings \na\n and \nb\n.\n\n\n\n\ncommonsubstr(\n    \"abbab\",\n    \"aabbb\"\n)\n# \"abb\"\n\n\n\n\n\n\n\n\neditdist(a, b, bound=inf)\n computes the \nedit distance\n between two strings \na\n and \nb\n.\n\n\n\n\nTo speedup the computation, a threshold of maximum cost \nbound=inf\n can be specified. When there is no satisfying result, \nNone\n is returned.\n\n\n\n\n\n\n\n\neditdist(\"dog\", \"frog\")\n# 2\n\n\n\n\n\n\n\n\ntagstats(tags, lines, separator=None)\n efficiently computes the number of lines containing each tag.\n\n\n\n\n\n\nTagStats\n is used to compute efficiently, where the common prefixes among tags are matched only once.\n\n\n\n\n\n\nseparator\n is a regex to tokenize each string. In default when \nseparator\n is \nNone\n, each string is not tokenized.\n\n\n\n\n\n\n\n\n\n\ntagstats(\n    [\"a b\", \"a c\", \"b c\"],\n    [\"a b c\", \"b c d\", \"c d e\"]\n)\n# {'a b': 1, 'a c': 0, 'b c': 2}\n\n\n\n\nTools for string transformations.\n\n\n\n\n\n\nstr2grams(s, n, pad=None)\n returns the ordered \nn\n-grams\n of string \ns\n.\n\n\n\n\nOptional padding at the start and end can be added by specifying \npad\n. \n\\0\n is usually a safe choice for \npad\n when not displaying.\n\n\n\n\n\n\n\n\nTools for checksums.\n\n\n\n\nsha1sum(f)\n, \nsha256sum(f)\n, \nsha512sum(f)\n, \nmd5sum(f)\n compute the respective checksum, accepting string, bytes, text file object, and binary file object.\n\n\n\n\n\n\nrangetools\n\n\nTools for statistics over ranges. Note that each range is closed on the left side, and open on the right side.\n\n\n\n\n\n\nhistogram(thresholds, data, leftmost=-inf)\n computes the \nhistogram\n over all the floats in \ndata\n.\n\n\n\n\n\n\nThe search space is divided by the thresholds of bins specified in \nthresholds\n.\n\n\n\n\n\n\nEach bin of the histogram is labelled by its lower threshold.\n\n\n\n\n\n\nAll values in the bin are no less than the current threshold and less than the next threshold.\n\n\n\n\n\n\nThe first bin is labelled by \nleftmost\n, which is \n-inf\n in default.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nhistogram(\n    [0.1, 0.5, 0.8, 0.9],\n    [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n)\n# {-inf: 1, 0.1: 4, 0.5: 3, 0.8: 1, 0.9: 2}\n\n\n\n\nTools for querying ranges.\n\n\n\n\n\n\nrangequery(keyvalues, query, func=min)\n efficiently finds the best value from the covered values in \nkeyvalues\n, if each key in \nkeyvalues\n is within the query range \nquery\n.\n\n\n\n\n\n\nImplemented by \nSegmentTree\n to solve the \nrange minimum query\n problem.\n\n\n\n\n\n\nfunc\n defines how the best value is computed, and defaults to \nmin\n for minimum value.\n\n\n\n\n\n\n\n\n\n\nrangequery(\n    {0.1: 1, 0.2: 3, 0.3: 0},\n    (0.2, 0.4)\n)\n# 0\n\n\n\n\nTools for transformations over ranges. Note that each range is closed on the left side, and open on the right side.\n\n\n\n\n\n\nintersect(a, b)\n computes the overlapping of two ranges \na\n and \nb\n. Returns \nNone\n if there is no overlapping.\n\n\n\n\n\n\nunion(a, b)\n computes the merging of two ranges \na\n and \nb\n. Returns \nNone\n if there is no overlapping.\n\n\n\n\n\n\nrangecover(whole, covers, key=len)\n solves the \nset cover problem\n by covering the universe range \nwhole\n as best as possible, using a subset of the covering ranges \ncovers\n.\n\n\n\n\nThis is an approximate algorithm, which means the returned result is not always the best.\n\n\n\n\n\n\n\n\nlist(rangecover(\n    (0, 1),\n    [(0, 0.4), (0.2, 0.5), (0.5, 0.8), (0.6, 0.9), (0.8, 1)]\n))\n# [(0, 0.4), (0.5, 0.8), (0.8, 1), (0.2, 0.5)]\n\n\n\n\n\n\n\n\ncovers(covered)\n merges the covered ranges \ncovered\n to resolve any overlap.\n\n\n\n\nCovered ranges in \ncovered\n are sorted by the left side of each range.\n\n\n\n\n\n\n\n\nlist(covers([(-inf, 0), (0.1, 0.2), (0.5, 0.7), (0.6, 0.9)]))\n# [(-inf, 0), (0.1, 0.2), (0.5, 0.9)]\n\n\n\n\n\n\n\n\ngaps(covered, whole=(-inf, inf))\n computes the uncovered ranges of the whole range \nwhole\n, given the covered ranges \ncovered\n.\n\n\n\n\n\n\nCovered ranges in \ncovered\n are sorted by the left side of each range.\n\n\n\n\n\n\nOverlaps among covered ranges \ncovered\n are resolved, like \ncovers(covered)\n.\n\n\n\n\n\n\n\n\n\n\nlist(gaps(\n    [(-inf, 0), (0.1, 0.2), (0.5, 0.7), (0.6, 0.9)],\n    (0, 1)\n))\n# [(0, 0.1), (0.2, 0.5), (0.9, 1)]\n\n\n\n\n\n\ndicttools\n\n\nTools for inverting dictionaries.\n\n\n\n\n\n\ninvert(d)\n inverts \n(Key, Value)\n pairs to \n(Value, Key)\n.\n\n\n\n\nIf multiple keys share the same value, the inverted directory keeps last of the respective keys.\n\n\n\n\n\n\n\n\ninvert_multiple(d)\n inverts \n(Key, List[Value])\n pairs to \n(Value, Key)\n.\n\n\n\n\nIf multiple keys share the same value, the inverted directory keeps last of the respective keys.\n\n\n\n\n\n\n\n\ninvert_safe(d)\n inverts \n(Key, Value)\n pairs to \n(Value, List[Key])\n.\n\n\n\n\nIf multiple keys share the same value, the inverted directory keeps a list of all the respective keys.\n\n\n\n\n\n\n\n\nTools for remapping elements.\n\n\n\n\n\n\nremap(data, mapping, key=None)\n remaps each unique element in \ndata\n according to function \nkey\n.\n\n\n\n\n\n\nmapping\n is a dictionary recording all the mappings, optionally containing previous mappings to reuse.\n\n\n\n\n\n\nIn default, \nkey\n returns integers starting from \n0\n.\n\n\n\n\n\n\n\n\n\n\nwordmap = {}\ndb = [list(remap(doc, wordmap)) for doc in docs]\n\n\n\n\nTools for indexing.\n\n\n\n\n\n\ninvertedindex(seqs)\n creates an \ninverted index\n.\n\n\n\n\nEach item's index is a list of \n(ID, position)\n pairs for all the sequences in \nseqs\n containing the item.\n\n\n\n\n\n\n\n\ndata = [s.split() for s in [\n    \"a b c d e\",\n    \"b b b d e\",\n    \"c b c c a\",\n    \"b b b c c\"\n]]\n\ninvertedindex(data)\n# {'a': [(0, 0), (2, 4)],\n#  'b': [(0, 1), (1, 0), (2, 1), (3, 0)],\n#  'c': [(0, 2), (2, 0), (3, 3)],\n#  'd': [(0, 3), (1, 3)],\n#  'e': [(0, 4), (1, 4)]}\n\n\n\n\n\n\n\n\nnextentries(data, entries)\n scans the sequences in \ndata\n from left to right after current entries \nentries\n, and returns each item and its respective following entries.\n\n\n\n\nEach entry is a pair of \n(ID, Position)\n denoting the sequence ID and its respective matching position.\n\n\n\n\n\n\n\n\n# same data from previous example\n\n# the first positions of `c` among sequences.\nentries = [(0, 2), (2, 0), (3, 3)]\n\nnextentries(data, entries)\n# {'d': [(0, 3)],\n#  'e': [(0, 4)],\n#  'b': [(2, 1)],\n#  'c': [(2, 2), (3, 4)],\n#  'a': [(2, 4)]}\n\n\n\n\nTools for flatten/unflatten a dictionary.\n\n\n\n\n\n\nflatten(d, force=False)\n flattens a dictionary by returning \n(Path, Value\n) tuples with each path \nPath\n from root to each value \nValue\n.\n\n\n\n\n\n\nFor each path, if any array with nested dictionary is encountered, the index of the array also becomes part of the path.\n\n\n\n\n\n\nIn default, only an array with nested dictionary is flatten. Instead, parameter \nforce\n can be specified to flatten any array. Note that an empty array contains no child and disappears after being flatten.\n\n\n\n\n\n\n\n\n\n\nflatten(json.loads(\"\"\"{\n  \"name\": \"John\",\n  \"address\": {\n    \"streetAddress\": \"21 2nd Street\",\n    \"city\": \"New York\",\n  },\n  \"phoneNumbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    }\n  ],\n  \"children\": [],\n  \"spouse\": null\n}\"\"\"))\n# {'name': 'John',\n#  ('address', 'streetAddress'): '21 2nd Street',\n#  ('address', 'city'): 'New York',\n#  (('phoneNumbers', 0), 'type'): 'home',\n#  (('phoneNumbers', 0), 'number'): '212 555-1234',\n#  (('phoneNumbers', 1), 'type'): 'office',\n#  (('phoneNumbers', 1), 'number'): '646 555-4567',\n#  'children': [],\n#  'spouse': None}\n\n\n\n\n\n\njsontools\n\n\nTools for flatten/unflatten a JSON object.\n\n\n\n\n\n\nflatten(data, force=False)\n flattens a JSON object by returning \n(Path, Value\n) tuples with each path \nPath\n from root to each value \nValue\n.\n\n\n\n\n\n\nFor each path, if any array with nested dictionary is encountered, the index of the array also becomes part of the path.\n\n\n\n\n\n\nIn default, only an array with nested dictionary is flatten. Instead, parameter \nforce\n can be specified to flatten any array. Note that an empty array contains no child and disappears after being flatten.\n\n\n\n\n\n\n\n\n\n\nflatten(json.loads(\"\"\"{\n  \"name\": \"John\",\n  \"address\": {\n    \"streetAddress\": \"21 2nd Street\",\n    \"city\": \"New York\",\n  },\n  \"phoneNumbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    }\n  ],\n  \"children\": [],\n  \"spouse\": null\n}\"\"\"))\n# {'name': 'John',\n#  'address.streetAddress': '21 2nd Street',\n#  'address.city': 'New York',\n#  'phoneNumbers[0].type': 'home',\n#  'phoneNumbers[0].number': '212 555-1234',\n#  'phoneNumbers[1].type': 'office',\n#  'phoneNumbers[1].number': '646 555-4567',\n#  'children': [],\n#  'spouse': None}\n\n\n\n\n\n\nsettools\n\n\nTools for matching sets.\n\n\n\n\nbestsubset(a, key)\n finds the best sub-set of \na\n that maximizes the key function \nkey\n.\n\n\n\n\nbestsubset({1, -2, 3, -4, 5, -6}, sum)\n# {1, 3, 5}\n\n\n\n\n\n\n\n\nsetcover(whole, covers, key=len)\n solves the \nset cover problem\n by covering the universe set \nwhole\n as best as possible, using a subset of the covering sets \ncovers\n.\n\n\n\n\n\n\nIn default, the size of each set \nlen\n is used as key function \nkey\n to measure the coverage.\n\n\n\n\n\n\nThis is an approximate algorithm, which means the returned result is not always the best.\n\n\n\n\n\n\n\n\n\n\nlist(setcover(\n    {1, 2, 3, 4, 5},\n    [{1, 2, 3}, {2, 3, 4}, {2, 4, 5}]\n))\n# [frozenset({1, 2, 3}), frozenset({2, 4, 5})]\n\n\n\n\nTools for set operations.\n\n\n\n\naddtoset(s, x)\n checks whether adding \nx\n to set \ns\n is successful.\n\n\n\n\nTools for set similarities.\n\n\n\n\n\n\njaccard(a, b)\n computes the \nJaccard similarity\n between two sets \na\n and \nb\n.\n\n\n\n\n\n\nmultisetjaccard(a, b)\n computes the \nJaccard similarity\n between two multi-sets (Counters) \na\n and \nb\n.\n\n\n\n\n\n\nweightedjaccard(a, b, key=sum)\n computes the weighted \nJaccard similarity\n between two sets \na\n and \nb\n, using function \nkey\n to compute the total weight of the elements within a set.\n\n\n\n\n\n\n\n\ntabletools\n\n\nTools for tables.\n\n\n\n\n\n\ntranspose(data)\n returns the transpose of table \ndata\n, i.e., switch rows and columns.\n\n\n\n\nUseful to switch table \ndata\n from row-based to column-based and backwards.\n\n\n\n\n\n\n\n\nlist(transpose([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]))\n# [[1, 4, 7],\n#  [2, 5, 8],\n#  [3, 6, 9]]\n\n\n\n\n\n\n\n\nloadcsv(path, delimiter=',')\n loads a CSV file, from either a file path or a file object.\n\n\n\n\n\n\ndumpcsv(path, data, delimiter=',')\n dumps a table \ndata\n in CSV, to either a file path or a file object.\n\n\n\n\n\n\n\n\nmathtools\n\n\nTools for math.\n\n\n\n\n\n\nsafediv(a, b)\n avoids the \ndivision by zero\n exception, by returning infinite with proper sign.\n\n\n\n\nClosely referring \nIEEE Standard 754\n.\n\n\n\n\n\n\n\n\n\n\nstattools\n\n\nTools for statistics.\n\n\n\n\n\n\nmedianabsdev(data)\n computes the \nmedian absolute deviation\n of a list of floats.\n\n\n\n\n\n\nentropy(data)\n computes the \nentropy\n of a list of any items.\n\n\n\n\nYou can also pass a dictionary of \n(item, frequency)\n as frequency distribution to \ndata\n.\n\n\n\n\n\n\n\n\nTools for binary classification.\n\n\n\n\n\n\nteststats(truths, predictions)\n matches the truth labels and the prediction labels. Return a tuples of \n(tp, fp, tn, fn)\n as \ntrue positive, false positive, true negative, and false negative\n.\n\n\n\n\n\n\naccuracy(tp, fp, tn, fn)\n returns the \naccuracy\n.\n\n\n\n\nNote that you can simply call \naccuracy(*teststats(truths, predictions))\n.\n\n\n\n\n\n\n\n\nprecision(tp, fp, tn, fn)\n and \nrecall(tp, fp, tn, fn)\n return the \nprecision and recall\n.\n\n\n\n\n\n\nf1(tp, fp, tn, fn, beta=1)\n returns the \nF-1 measure\n in default, and returns the F-\u03b2 measure when \nbeta\n is specified.\n\n\n\n\n\n\n\n\nmisctools\n\n\nTools for miscellaneous purposes.\n\n\n\n\n\n\ncmp(a, b)\n restores the useful \ncmp\n function previously in Python 2.\n\n\n\n\nImplemented according to \nWhat's New in Python 3.0\n.\n\n\n\n\n\n\n\n\nparsebool(s)\n parses a string to boolean, if its lowercase equals to either \n1\n, \ntrue\n, or \nyes\n.\n\n\n\n\n\n\n\n\nprinttools\n\n\nTools for non-functional but useful printing purposes.\n\n\n\n\n\n\nprint2(*args, **kwargs)\n redirects the output of \nprint\n to standard error.\n\n\n\n\nThe same parameters are accepted.\n\n\n\n\n\n\n\n\n\n\ndebugtools\n\n\nTools for non-functional but useful debugging purposes.\n\n\n\n\n\n\nstopwatch()\n returns both the duration since program start and the duration since last call in seconds.\n\n\n\n\nTechnically, the stopwatch starts when \ndebugtools\n is imported.\n\n\n\n\n\n\n\n\npeakmem()\n returns the peak memory usage since program start.\n\n\n\n\nIn bytes on macOS, and in kilobytes on Linux.",
            "title": "Functions"
        },
        {
            "location": "/functions/#functions",
            "text": "",
            "title": "Functions"
        },
        {
            "location": "/functions/#seqtools",
            "text": "Tools for matching sequences (including strings), without gaps allowed between matching items. Note that empty sequence is always a sub-sequence of any other sequence.   bestsubseq(a, key)  finds the best sub-sequence of  a  that maximizes the key function  key .   bestsubseq([1, -2, 3, -4, 5, -6], sum)\n# [5]    findallsubseqs(a, b, overlap=False)  returns all the positions where  a  is a sub-sequence of  b .    In default, no overlapping is allowed. You can change the behavior by specify  overlap .    Unlike other function in  seqtools , nothing is returned when  a  is empty.      findsubseq(a, b)  returns the first position where  a  is a sub-sequence of  b , or  -1  when not found.    issubseq(a, b)  checks if  a  is a sub-sequence of  b .    commonsubseq(a, b)  finds the  longest common sub-sequence  among two sequences  a  and  b .    commonsubseq(\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 1, 1]\n)\n# [0, 1, 1]  Tools for matching sequences (including strings), with gaps allowed between matching items. Note that empty sequence is always a sub-sequence of any other sequence.   bestsubseqwithgap(a, key)  finds the best sub-sequence of  a  that maximizes the key function  key , where gaps are allowed.   bestsubseqwithgap([1, -2, 3, -4, 5, -6], sum)\n# [1, 3, 5]    findsubseqwithgap(a, b)  returns the matching positions where  a  is a sub-sequence of  b , where gaps are allowed, or  None  when not found.    issubseqwithgap(a, b)  checks if  a  is a sub-sequence of  b , where gaps are allowed.    commonsubseqwithgap(a, b)  finds the  longest common sub-sequence  among two sequences  a  and  b , where gaps are allowed.    commonsubseqwithgap(\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 1, 1]\n)\n# [0, 1, 1, 1]    align(a, b, cost=None, bound=inf, default=None)   aligns  two sequences  a  and  b , such that the total cost of the aligned sequences given the pair-wise cost function  cost(x, y)  is minimized.    Assume the aligned sequences are  a'  and  b' . The total cost is  sum(cost(x, y) for x, y in zip(a', b')) .    Both the minimum total cost and the respective aligned sequences are returned as a tuple.    In default, the cost function  cost(x, y)  returns  1  when  x == y  and  0  when not. This is equal to the  edit distance .    To speedup the computation, a threshold of maximum cost  bound=inf  can be specified. When there is no satisfying result,  None  is returned.      align(\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 1, 1]\n)\n# (2, ([0, None, 1, 1, 0,    1],\n#      [0, 0,    1, 1, None, 1]))\n\nalign(\n    [0, 1, 1, 0, 1],\n    [0, 0, 1, 1, 1],\n    bound=1\n)\n# None  Tools for comparing sequences (including strings).    productcmp(x, y)  compares two sequences  x  and  y  with equal length according to  product order . Returns  -1  if smaller,  0  if equal,  1  if greater, and  None  if not comparable.   Throw exception if  x  and  y  have different lengths.     Tools for sorting sequences.   sortedbyrank(data, ranks, reverse=False)  returns the sorted list of  data , according to the respective rank of each individual element in  ranks .   Tools for encoding/decoding sequences.    compress(data, key=None)  compresses the sequence by encoding continuous identical  Item  to  (Item, Count) , according to  run-length encoding .   Different from  itertools.compress .     list(compress([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]))\n# [(1, 1), (2, 2), (3, 3), (4, 4)]    decompress(data)  decompresses the sequence by decoding  (Item, Count)  to continuous identical  Item , according to  run-length encoding .    todeltas(data, op=operator.sub)  compresses the sequence by encoding the difference between previous and current items, according to  delta encoding .   For custom type of item, either define the  -  operator or specify the  op  function computing the difference.     list(todeltas([1, 2, 2, 3, 3, 3, 4, 4, 4, 4]))\n# [1, 1, 0, 1, 0, 0, 1, 0, 0, 0]    fromdeltas(data, op=operator.add)  decompresses the sequence by decoding the difference between previous and current items, according to  delta encoding .   For custom type of item, either define the  +  operator or specify the  op  function merging the difference.     Tools for joining sequences.    join(leftseq, rightseq, leftkey=None, rightkey=None, leftdefault=no_default, rightdefault=no_default)  joins two sequences, optionally according to  leftkey  and  rightkey , respectively. Outer join is also supported.    If both two sequences are sorted according to  leftkey  and  rightkey , respectively, then optimized  sortedtools.join  with the same API should be used for better efficiency.    Unlike  sortedtools.join ,  join  is just a wrapper of  toolz.itertools.join  with a slightly more friendly API.",
            "title": "seqtools"
        },
        {
            "location": "/functions/#sortedtools",
            "text": "Tools for joining sorted sequences.    sortedjoin(leftseq, rightseq, leftkey=None, rightkey=None, leftdefault=no_default, rightdefault=no_default)  joins two sequences, optionally according to  leftkey  and  rightkey , respectively. Outer join is also supported.    Two sequences must be already sorted according to  leftkey  and  rightkey , respectively.    sortedjoin  is completely lazy, and more efficient than  seqtools.join  and its underneath  toolz.itertools.join .      list(sortedjoin([-1, -1, -2, -4, -5, -6], [0, 1, 1, 2, 3, 4, 5, 5], leftkey=abs, leftdefault=None))\n# [(None, 0),\n#  (-1, 1),\n#  (-1, 1),\n#  (-1, 1),\n#  (-1, 1),\n#  (-2, 2),\n#  (None, 3),\n#  (-4, 4),\n#  (-5, 5),\n#  (-5, 5)]  Tools for matching sorted sequences.    sortedcommon(a, b, key=None)  returns the common elements between  a  and  b .   When both  a  and  b  are sorted sets with no duplicate element, equal to  sorted(set(a) & set(b))  but more efficient.     sortedalone(a, b, key=None)  returns the elements not in both  a  and  b .   When both  a  and  b  are sorted sets with no duplicate element, equal to  sorted((set(a) | set(b)) - (set(a) & set(b)))  but more efficient.     sorteddiff(a, b, key=None)  returns the elements only in  a  and not in  b .   When both  a  and  b  are sorted sets with no duplicate element, equal to  sorted(set(a) - set(b))  but more efficient.     issubsorted(a, b, key=None)  checks if  a  is a sorted sub-sequence of  b .   When both  a  and  b  are sorted sets with no duplicate element, equal to  set(a) <= set(b)  but more efficient.",
            "title": "sortedtools"
        },
        {
            "location": "/functions/#strtools",
            "text": "Tools for string matching.   commonsubstr(a, b)  finds the  longest common sub-string  among two strings  a  and  b .   commonsubstr(\n    \"abbab\",\n    \"aabbb\"\n)\n# \"abb\"    editdist(a, b, bound=inf)  computes the  edit distance  between two strings  a  and  b .   To speedup the computation, a threshold of maximum cost  bound=inf  can be specified. When there is no satisfying result,  None  is returned.     editdist(\"dog\", \"frog\")\n# 2    tagstats(tags, lines, separator=None)  efficiently computes the number of lines containing each tag.    TagStats  is used to compute efficiently, where the common prefixes among tags are matched only once.    separator  is a regex to tokenize each string. In default when  separator  is  None , each string is not tokenized.      tagstats(\n    [\"a b\", \"a c\", \"b c\"],\n    [\"a b c\", \"b c d\", \"c d e\"]\n)\n# {'a b': 1, 'a c': 0, 'b c': 2}  Tools for string transformations.    str2grams(s, n, pad=None)  returns the ordered  n -grams  of string  s .   Optional padding at the start and end can be added by specifying  pad .  \\0  is usually a safe choice for  pad  when not displaying.     Tools for checksums.   sha1sum(f) ,  sha256sum(f) ,  sha512sum(f) ,  md5sum(f)  compute the respective checksum, accepting string, bytes, text file object, and binary file object.",
            "title": "strtools"
        },
        {
            "location": "/functions/#rangetools",
            "text": "Tools for statistics over ranges. Note that each range is closed on the left side, and open on the right side.    histogram(thresholds, data, leftmost=-inf)  computes the  histogram  over all the floats in  data .    The search space is divided by the thresholds of bins specified in  thresholds .    Each bin of the histogram is labelled by its lower threshold.    All values in the bin are no less than the current threshold and less than the next threshold.    The first bin is labelled by  leftmost , which is  -inf  in default.        histogram(\n    [0.1, 0.5, 0.8, 0.9],\n    [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1]\n)\n# {-inf: 1, 0.1: 4, 0.5: 3, 0.8: 1, 0.9: 2}  Tools for querying ranges.    rangequery(keyvalues, query, func=min)  efficiently finds the best value from the covered values in  keyvalues , if each key in  keyvalues  is within the query range  query .    Implemented by  SegmentTree  to solve the  range minimum query  problem.    func  defines how the best value is computed, and defaults to  min  for minimum value.      rangequery(\n    {0.1: 1, 0.2: 3, 0.3: 0},\n    (0.2, 0.4)\n)\n# 0  Tools for transformations over ranges. Note that each range is closed on the left side, and open on the right side.    intersect(a, b)  computes the overlapping of two ranges  a  and  b . Returns  None  if there is no overlapping.    union(a, b)  computes the merging of two ranges  a  and  b . Returns  None  if there is no overlapping.    rangecover(whole, covers, key=len)  solves the  set cover problem  by covering the universe range  whole  as best as possible, using a subset of the covering ranges  covers .   This is an approximate algorithm, which means the returned result is not always the best.     list(rangecover(\n    (0, 1),\n    [(0, 0.4), (0.2, 0.5), (0.5, 0.8), (0.6, 0.9), (0.8, 1)]\n))\n# [(0, 0.4), (0.5, 0.8), (0.8, 1), (0.2, 0.5)]    covers(covered)  merges the covered ranges  covered  to resolve any overlap.   Covered ranges in  covered  are sorted by the left side of each range.     list(covers([(-inf, 0), (0.1, 0.2), (0.5, 0.7), (0.6, 0.9)]))\n# [(-inf, 0), (0.1, 0.2), (0.5, 0.9)]    gaps(covered, whole=(-inf, inf))  computes the uncovered ranges of the whole range  whole , given the covered ranges  covered .    Covered ranges in  covered  are sorted by the left side of each range.    Overlaps among covered ranges  covered  are resolved, like  covers(covered) .      list(gaps(\n    [(-inf, 0), (0.1, 0.2), (0.5, 0.7), (0.6, 0.9)],\n    (0, 1)\n))\n# [(0, 0.1), (0.2, 0.5), (0.9, 1)]",
            "title": "rangetools"
        },
        {
            "location": "/functions/#dicttools",
            "text": "Tools for inverting dictionaries.    invert(d)  inverts  (Key, Value)  pairs to  (Value, Key) .   If multiple keys share the same value, the inverted directory keeps last of the respective keys.     invert_multiple(d)  inverts  (Key, List[Value])  pairs to  (Value, Key) .   If multiple keys share the same value, the inverted directory keeps last of the respective keys.     invert_safe(d)  inverts  (Key, Value)  pairs to  (Value, List[Key]) .   If multiple keys share the same value, the inverted directory keeps a list of all the respective keys.     Tools for remapping elements.    remap(data, mapping, key=None)  remaps each unique element in  data  according to function  key .    mapping  is a dictionary recording all the mappings, optionally containing previous mappings to reuse.    In default,  key  returns integers starting from  0 .      wordmap = {}\ndb = [list(remap(doc, wordmap)) for doc in docs]  Tools for indexing.    invertedindex(seqs)  creates an  inverted index .   Each item's index is a list of  (ID, position)  pairs for all the sequences in  seqs  containing the item.     data = [s.split() for s in [\n    \"a b c d e\",\n    \"b b b d e\",\n    \"c b c c a\",\n    \"b b b c c\"\n]]\n\ninvertedindex(data)\n# {'a': [(0, 0), (2, 4)],\n#  'b': [(0, 1), (1, 0), (2, 1), (3, 0)],\n#  'c': [(0, 2), (2, 0), (3, 3)],\n#  'd': [(0, 3), (1, 3)],\n#  'e': [(0, 4), (1, 4)]}    nextentries(data, entries)  scans the sequences in  data  from left to right after current entries  entries , and returns each item and its respective following entries.   Each entry is a pair of  (ID, Position)  denoting the sequence ID and its respective matching position.     # same data from previous example\n\n# the first positions of `c` among sequences.\nentries = [(0, 2), (2, 0), (3, 3)]\n\nnextentries(data, entries)\n# {'d': [(0, 3)],\n#  'e': [(0, 4)],\n#  'b': [(2, 1)],\n#  'c': [(2, 2), (3, 4)],\n#  'a': [(2, 4)]}  Tools for flatten/unflatten a dictionary.    flatten(d, force=False)  flattens a dictionary by returning  (Path, Value ) tuples with each path  Path  from root to each value  Value .    For each path, if any array with nested dictionary is encountered, the index of the array also becomes part of the path.    In default, only an array with nested dictionary is flatten. Instead, parameter  force  can be specified to flatten any array. Note that an empty array contains no child and disappears after being flatten.      flatten(json.loads(\"\"\"{\n  \"name\": \"John\",\n  \"address\": {\n    \"streetAddress\": \"21 2nd Street\",\n    \"city\": \"New York\",\n  },\n  \"phoneNumbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    }\n  ],\n  \"children\": [],\n  \"spouse\": null\n}\"\"\"))\n# {'name': 'John',\n#  ('address', 'streetAddress'): '21 2nd Street',\n#  ('address', 'city'): 'New York',\n#  (('phoneNumbers', 0), 'type'): 'home',\n#  (('phoneNumbers', 0), 'number'): '212 555-1234',\n#  (('phoneNumbers', 1), 'type'): 'office',\n#  (('phoneNumbers', 1), 'number'): '646 555-4567',\n#  'children': [],\n#  'spouse': None}",
            "title": "dicttools"
        },
        {
            "location": "/functions/#jsontools",
            "text": "Tools for flatten/unflatten a JSON object.    flatten(data, force=False)  flattens a JSON object by returning  (Path, Value ) tuples with each path  Path  from root to each value  Value .    For each path, if any array with nested dictionary is encountered, the index of the array also becomes part of the path.    In default, only an array with nested dictionary is flatten. Instead, parameter  force  can be specified to flatten any array. Note that an empty array contains no child and disappears after being flatten.      flatten(json.loads(\"\"\"{\n  \"name\": \"John\",\n  \"address\": {\n    \"streetAddress\": \"21 2nd Street\",\n    \"city\": \"New York\",\n  },\n  \"phoneNumbers\": [\n    {\n      \"type\": \"home\",\n      \"number\": \"212 555-1234\"\n    },\n    {\n      \"type\": \"office\",\n      \"number\": \"646 555-4567\"\n    }\n  ],\n  \"children\": [],\n  \"spouse\": null\n}\"\"\"))\n# {'name': 'John',\n#  'address.streetAddress': '21 2nd Street',\n#  'address.city': 'New York',\n#  'phoneNumbers[0].type': 'home',\n#  'phoneNumbers[0].number': '212 555-1234',\n#  'phoneNumbers[1].type': 'office',\n#  'phoneNumbers[1].number': '646 555-4567',\n#  'children': [],\n#  'spouse': None}",
            "title": "jsontools"
        },
        {
            "location": "/functions/#settools",
            "text": "Tools for matching sets.   bestsubset(a, key)  finds the best sub-set of  a  that maximizes the key function  key .   bestsubset({1, -2, 3, -4, 5, -6}, sum)\n# {1, 3, 5}    setcover(whole, covers, key=len)  solves the  set cover problem  by covering the universe set  whole  as best as possible, using a subset of the covering sets  covers .    In default, the size of each set  len  is used as key function  key  to measure the coverage.    This is an approximate algorithm, which means the returned result is not always the best.      list(setcover(\n    {1, 2, 3, 4, 5},\n    [{1, 2, 3}, {2, 3, 4}, {2, 4, 5}]\n))\n# [frozenset({1, 2, 3}), frozenset({2, 4, 5})]  Tools for set operations.   addtoset(s, x)  checks whether adding  x  to set  s  is successful.   Tools for set similarities.    jaccard(a, b)  computes the  Jaccard similarity  between two sets  a  and  b .    multisetjaccard(a, b)  computes the  Jaccard similarity  between two multi-sets (Counters)  a  and  b .    weightedjaccard(a, b, key=sum)  computes the weighted  Jaccard similarity  between two sets  a  and  b , using function  key  to compute the total weight of the elements within a set.",
            "title": "settools"
        },
        {
            "location": "/functions/#tabletools",
            "text": "Tools for tables.    transpose(data)  returns the transpose of table  data , i.e., switch rows and columns.   Useful to switch table  data  from row-based to column-based and backwards.     list(transpose([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]))\n# [[1, 4, 7],\n#  [2, 5, 8],\n#  [3, 6, 9]]    loadcsv(path, delimiter=',')  loads a CSV file, from either a file path or a file object.    dumpcsv(path, data, delimiter=',')  dumps a table  data  in CSV, to either a file path or a file object.",
            "title": "tabletools"
        },
        {
            "location": "/functions/#mathtools",
            "text": "Tools for math.    safediv(a, b)  avoids the  division by zero  exception, by returning infinite with proper sign.   Closely referring  IEEE Standard 754 .",
            "title": "mathtools"
        },
        {
            "location": "/functions/#stattools",
            "text": "Tools for statistics.    medianabsdev(data)  computes the  median absolute deviation  of a list of floats.    entropy(data)  computes the  entropy  of a list of any items.   You can also pass a dictionary of  (item, frequency)  as frequency distribution to  data .     Tools for binary classification.    teststats(truths, predictions)  matches the truth labels and the prediction labels. Return a tuples of  (tp, fp, tn, fn)  as  true positive, false positive, true negative, and false negative .    accuracy(tp, fp, tn, fn)  returns the  accuracy .   Note that you can simply call  accuracy(*teststats(truths, predictions)) .     precision(tp, fp, tn, fn)  and  recall(tp, fp, tn, fn)  return the  precision and recall .    f1(tp, fp, tn, fn, beta=1)  returns the  F-1 measure  in default, and returns the F-\u03b2 measure when  beta  is specified.",
            "title": "stattools"
        },
        {
            "location": "/functions/#misctools",
            "text": "Tools for miscellaneous purposes.    cmp(a, b)  restores the useful  cmp  function previously in Python 2.   Implemented according to  What's New in Python 3.0 .     parsebool(s)  parses a string to boolean, if its lowercase equals to either  1 ,  true , or  yes .",
            "title": "misctools"
        },
        {
            "location": "/functions/#printtools",
            "text": "Tools for non-functional but useful printing purposes.    print2(*args, **kwargs)  redirects the output of  print  to standard error.   The same parameters are accepted.",
            "title": "printtools"
        },
        {
            "location": "/functions/#debugtools",
            "text": "Tools for non-functional but useful debugging purposes.    stopwatch()  returns both the duration since program start and the duration since last call in seconds.   Technically, the stopwatch starts when  debugtools  is imported.     peakmem()  returns the peak memory usage since program start.   In bytes on macOS, and in kilobytes on Linux.",
            "title": "debugtools"
        },
        {
            "location": "/datastructures/",
            "text": "Data Structures\n\n\n\n\ndisjointsets.DisjointSets\n\n\nDisjoint sets\n with path compression, based a lot on this \nimplementation\n. After \nd = DisjointSets()\n:\n\n\n\n\n\n\nd.add(x)\n adds a new disjoint set containing \nx\n.\n\n\n\n\n\n\nd[x]\n returns the representing element of the disjoint set containing \nx\n.\n\n\n\n\n\n\nd.disjoints()\n returns all the representing elements and their respective disjoint sets.\n\n\n\n\n\n\nd.union(*xs)\n union all the elements in \nxs\n into a single disjoint set.\n\n\n\n\n\n\n\n\ndefaultlist.defaultlist\n\n\nA sub-class of \nlist\n that automatically grows when setting an index beyond the list size.\n\n\n\n\n\n\nWhen creating a list, use \nDefaultList(default, ...)\n to specify a function that returns default value when visiting an unassigned index.\n\n\n\n\n\n\nThis library is designed to be highly similar to \ncollections.defaultdict\n in standard library.\n\n\n\n\n\n\nl = DefaultList(lambda: None, range(10))\n\nl[11] = 11\n\nl\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, None, 11]\n\n\n\n\n\n\nsegmenttree.SegmentTree\n\n\nThis data structure solves the \nrange minimum query problem\n of finding the minimal value in a sub-array of an array of comparable objects. Different from the original problem, this data structure also supports updating the values.\n\n\nInitialization\n\n\nUse \nSegmentTree()\n to initialize the tree with a set of keys, in \ncomparable and hashable\n type.\n\n\n\n\n\n\nfunc=min\n specifies how the best value is computed for any range of keys.\n\n\n\n\n\n\ndefault=None\n specifies the default value for each key.\n\n\n\n\n\n\nmaxChildNum=2\n specifies the maximum number of children for each node.\n\n\n\n\n\n\ntree = SegmentTree(\n    {1, 2, 3, 4, 5},\n    func=min, default=0, maxChildNum=2\n)\n\n\n\n\nThe space complexity should be $O(n)$.\n\n\nUpdating\n\n\nYou need to use \nupdate()\n to initialize the values, or update the values if necessary, by specifying a dictionary of key/value pairs. Currently, adding new keys is not supported yet.\n\n\ntree.update({1: 3, 4: 6})\n\n\n\n\nGiven m values updated, the time complexity should be $O(m^2)$.\n\n\nQuerying\n\n\nUse \nquery()\n to to find the best value of a range of keys. The range is denoted by a tuple \n(a, b)\n, representing each key \nx\n such that \na <= x < b\n. The range here is closed on the left side and open on the right side, consistent with Python tradition.\n\n\ntree.query((1, 3))\n\n\n\n\nThe time complexity should be $O(log n)$.",
            "title": "Data Structures"
        },
        {
            "location": "/datastructures/#data-structures",
            "text": "",
            "title": "Data Structures"
        },
        {
            "location": "/datastructures/#disjointsetsdisjointsets",
            "text": "Disjoint sets  with path compression, based a lot on this  implementation . After  d = DisjointSets() :    d.add(x)  adds a new disjoint set containing  x .    d[x]  returns the representing element of the disjoint set containing  x .    d.disjoints()  returns all the representing elements and their respective disjoint sets.    d.union(*xs)  union all the elements in  xs  into a single disjoint set.",
            "title": "disjointsets.DisjointSets"
        },
        {
            "location": "/datastructures/#defaultlistdefaultlist",
            "text": "A sub-class of  list  that automatically grows when setting an index beyond the list size.    When creating a list, use  DefaultList(default, ...)  to specify a function that returns default value when visiting an unassigned index.    This library is designed to be highly similar to  collections.defaultdict  in standard library.    l = DefaultList(lambda: None, range(10))\n\nl[11] = 11\n\nl\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, None, 11]",
            "title": "defaultlist.defaultlist"
        },
        {
            "location": "/datastructures/#segmenttreesegmenttree",
            "text": "This data structure solves the  range minimum query problem  of finding the minimal value in a sub-array of an array of comparable objects. Different from the original problem, this data structure also supports updating the values.",
            "title": "segmenttree.SegmentTree"
        },
        {
            "location": "/datastructures/#initialization",
            "text": "Use  SegmentTree()  to initialize the tree with a set of keys, in  comparable and hashable  type.    func=min  specifies how the best value is computed for any range of keys.    default=None  specifies the default value for each key.    maxChildNum=2  specifies the maximum number of children for each node.    tree = SegmentTree(\n    {1, 2, 3, 4, 5},\n    func=min, default=0, maxChildNum=2\n)  The space complexity should be $O(n)$.",
            "title": "Initialization"
        },
        {
            "location": "/datastructures/#updating",
            "text": "You need to use  update()  to initialize the values, or update the values if necessary, by specifying a dictionary of key/value pairs. Currently, adding new keys is not supported yet.  tree.update({1: 3, 4: 6})  Given m values updated, the time complexity should be $O(m^2)$.",
            "title": "Updating"
        },
        {
            "location": "/datastructures/#querying",
            "text": "Use  query()  to to find the best value of a range of keys. The range is denoted by a tuple  (a, b) , representing each key  x  such that  a <= x < b . The range here is closed on the left side and open on the right side, consistent with Python tradition.  tree.query((1, 3))  The time complexity should be $O(log n)$.",
            "title": "Querying"
        },
        {
            "location": "/cli/",
            "text": "CLI Tools\n\n\nPlease check each individual script for more details.\n\n\ndicttools.remap\n\n\nUsage:\n    extratools-remap <mapping>\n\n\n\n\nCode\n\n\njsontools.flatten\n\n\nUsage:\n    extratools-flatten [--force]\n\n\n\n\nCode\n\n\nstattools.teststats\n\n\nUsage:\n    extratools-teststats <truth> <prediction>\n\n\n\n\nCode",
            "title": "CLI Tools"
        },
        {
            "location": "/cli/#cli-tools",
            "text": "Please check each individual script for more details.  dicttools.remap  Usage:\n    extratools-remap <mapping>  Code  jsontools.flatten  Usage:\n    extratools-flatten [--force]  Code  stattools.teststats  Usage:\n    extratools-teststats <truth> <prediction>  Code",
            "title": "CLI Tools"
        }
    ]
}