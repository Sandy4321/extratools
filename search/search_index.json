{
    "docs": [
        {
            "location": "/",
            "text": "Functions\n\u00b6\n\n\ndebugtools\n\n\n4+ tools for debugging purposes.\n\n\ndicttools\n\n\n7+ tools for operating dictionaries.\n\n\njsontools\n\n\n1+ tools for operating JSON data.\n\n\nmathtools\n\n\n2+ tools for math.\n\n\nmisctools\n\n\n2+ tools for miscellaneous purposes.\n\n\nprinttools\n\n\n5+ tools for printing purposes.\n\n\nrangetools\n\n\n7+ tools for operating ranges/intervals.\n\n\nseqtools\n\n\n29+ tools for operating sequences.\n\n\nsettools\n\n\n6+ tools for operating sets.\n\n\nsortedtools\n\n\n8+ tools for operating sorted sequences.\n\n\nstattools\n\n\n7+ tools for statistics.\n\n\nstrtools\n\n\n12+ tools for operating strings.\n\n\ntabletools\n\n\n9+ tools for operating tables/matrices.\n\n\nData Structures\n\u00b6\n\n\ndefaultlist.DefaultList\n\n\nAn implementation of \nlist\n that grows if necessary when accessing.\n\n\ndisjointsets.DisjointSets\n\n\nAn implementation of disjoint sets.\n\n\nsegmenttree.SegmentTree\n\n\nAn implementation of segment tree.\n\n\nCLI Tools\n\u00b6\n\n\ndicttools.remap\n\n\nCLI for \ndicttools.remap\n.\n\n\njsontools.flatten\n\n\nCLI for \njsontools.flatten\n.\n\n\nstattools.teststats\n\n\nCLI for \nstattools.teststats\n.",
            "title": "Index"
        },
        {
            "location": "/#functions",
            "text": "debugtools  4+ tools for debugging purposes.  dicttools  7+ tools for operating dictionaries.  jsontools  1+ tools for operating JSON data.  mathtools  2+ tools for math.  misctools  2+ tools for miscellaneous purposes.  printtools  5+ tools for printing purposes.  rangetools  7+ tools for operating ranges/intervals.  seqtools  29+ tools for operating sequences.  settools  6+ tools for operating sets.  sortedtools  8+ tools for operating sorted sequences.  stattools  7+ tools for statistics.  strtools  12+ tools for operating strings.  tabletools  9+ tools for operating tables/matrices.",
            "title": "Functions"
        },
        {
            "location": "/#data-structures",
            "text": "defaultlist.DefaultList  An implementation of  list  that grows if necessary when accessing.  disjointsets.DisjointSets  An implementation of disjoint sets.  segmenttree.SegmentTree  An implementation of segment tree.",
            "title": "Data Structures"
        },
        {
            "location": "/#cli-tools",
            "text": "dicttools.remap  CLI for  dicttools.remap .  jsontools.flatten  CLI for  jsontools.flatten .  stattools.teststats  CLI for  stattools.teststats .",
            "title": "CLI Tools"
        },
        {
            "location": "/README/",
            "text": "Almost 100 extra functional tools that go beyond standard library\u2019s \nitertools\n, \nfunctools\n, etc. and popular third-party libraries like \ntoolz\n, \nfancy\n, and \nmore-itertools\n.\n\n\n\n\n\n\nLike \ntoolz\n and others, most of the tools are designed to be efficient, pure, and lazy. Several useful yet non-functional tools are also included.\n\n\n\n\n\n\nWhile \ntoolz\n and others target basic scenarios, most tools in this library target more advanced and complete scenarios.\n\n\n\n\n\n\nA few useful CLI tools for respective functions are also installed. They are available as \nextratools-[funcname]\n.\n\n\n\n\n\n\nFull documentation available \nhere\n.\n\n\nPlans\n\u00b6\n\n\nThis library is under active development, and new functions are added on regular basis.\n\n\n\n\n\n\nAny idea or contribution is highly welcome.\n\n\n\n\n\n\nCurrently adopted by \nTopSim\n and \nPrefixSpan-py\n.\n\n\n\n\n\n\nBesides other interesting ideas, I am planning to make the following updates in recent days/weeks/months.\n\n\n\n\n\n\nAdd \ndicttools.unflatten\n and \njsontools.unflatten\n.\n\n\n\n\n\n\nAdd \ntrie\n and \nsuffixtree\n (according to \ngeneralized suffix tree\n).\n\n\n\n\n\n\nUpdate \nseqtools.commonsubseq\n, \nseqtools.commonsubseqwithgap\n, \nseqtools.align\n, and \nstrtools.commonsubstr\n to support more than two sequences/strings.\n\n\n\n\n\n\nIndex of Available Tools\n\u00b6\n\n\n\n\nFunctions:\n\n\n\n\ndebugtools\n\n\ndicttools\n\n\njsontools\n\n\nmathtools\n\n\nmisctools\n\n\nprinttools\n\n\nrangetools\n\n\nseqtools\n\n\nsettools\n\n\nsortedtools\n\n\nstattools\n\n\nstrtools\n\n\ntabletools\n\n\n\n\nData Structures:\n\n\n\n\ndefaultlist\n\n\ndisjointsets\n\n\nsegmenttree\n\n\n\n\nCLI Tools:\n\n\n\n\ndicttools.remap\n\n\njsontools.flatten\n\n\nstattools.teststats\n\n\nExamples\n\u00b6\n\n\nHere are three examples out of dozens of our tools.\n\n\n\n\nseqtools.compress(data, key=None)\n compresses the sequence by encoding continuous identical \nItem\n to \n(Item, Count)\n, according to \nrun-length encoding\n.\n\n\n\n\nlist(compress([\n1\n,\n \n2\n,\n \n2\n,\n \n3\n,\n \n3\n,\n \n3\n,\n \n4\n,\n \n4\n,\n \n4\n,\n \n4\n]))\n\n\n# [(1, 1), (2, 2), (3, 3), (4, 4)]\n\n\n\n\n\n\n\n\nrangetools.gaps(covered, whole=(-inf, inf))\n computes the uncovered ranges of the whole range \nwhole\n, given the covered ranges \ncovered\n.\n\n\n\n\nlist(gaps(\n\n    \n[(\n-\ninf,\n \n0\n),\n \n(\n0.1\n,\n \n0.2\n),\n \n(\n0.5\n,\n \n0.7\n),\n \n(\n0.6\n,\n \n0.9\n)],\n\n    \n(\n0\n,\n \n1\n)\n\n\n))\n\n\n# [(0, 0.1), (0.2, 0.5), (0.9, 1)]\n\n\n\n\n\n\n\n\njsontools.flatten(data, force=False)\n flattens a JSON object by returning \n(Path, Value\n) tuples with each path \nPath\n from root to each value \nValue\n.\n\n\n\n\nflatten(json\n.\nloads(\n\"\"\"{\n\n\n  \"name\": \"John\",\n\n\n  \"address\": {\n\n\n    \"streetAddress\": \"21 2nd Street\",\n\n\n    \"city\": \"New York\",\n\n\n  },\n\n\n  \"phoneNumbers\": [\n\n\n    {\n\n\n      \"type\": \"home\",\n\n\n      \"number\": \"212 555-1234\"\n\n\n    },\n\n\n    {\n\n\n      \"type\": \"office\",\n\n\n      \"number\": \"646 555-4567\"\n\n\n    }\n\n\n  ],\n\n\n  \"children\": [],\n\n\n  \"spouse\": null\n\n\n}\"\"\"\n))\n\n\n# {'name': 'John',\n\n\n#  'address.streetAddress': '21 2nd Street',\n\n\n#  'address.city': 'New York',\n\n\n#  'phoneNumbers[0].type': 'home',\n\n\n#  'phoneNumbers[0].number': '212 555-1234',\n\n\n#  'phoneNumbers[1].type': 'office',\n\n\n#  'phoneNumbers[1].number': '646 555-4567',\n\n\n#  'children': [],\n\n\n#  'spouse': None}\n\n\n\n\n\n\nInstallation\n\u00b6\n\n\nThis package is available on PyPI. Just use \npip3 install -U extratools\n to install it.\n\n\nOther Libraries\n\u00b6\n\n\nThe following libraries are highly recommended to use together with \nextratools\n.\n\n\ntoolz\n\n\nsortedcontainers",
            "title": "README"
        },
        {
            "location": "/README/#plans",
            "text": "This library is under active development, and new functions are added on regular basis.    Any idea or contribution is highly welcome.    Currently adopted by  TopSim  and  PrefixSpan-py .    Besides other interesting ideas, I am planning to make the following updates in recent days/weeks/months.    Add  dicttools.unflatten  and  jsontools.unflatten .    Add  trie  and  suffixtree  (according to  generalized suffix tree ).    Update  seqtools.commonsubseq ,  seqtools.commonsubseqwithgap ,  seqtools.align , and  strtools.commonsubstr  to support more than two sequences/strings.",
            "title": "Plans"
        },
        {
            "location": "/README/#index-of-available-tools",
            "text": "Functions:   debugtools  dicttools  jsontools  mathtools  misctools  printtools  rangetools  seqtools  settools  sortedtools  stattools  strtools  tabletools   Data Structures:   defaultlist  disjointsets  segmenttree   CLI Tools:   dicttools.remap  jsontools.flatten  stattools.teststats",
            "title": "Index of Available Tools"
        },
        {
            "location": "/README/#examples",
            "text": "Here are three examples out of dozens of our tools.   seqtools.compress(data, key=None)  compresses the sequence by encoding continuous identical  Item  to  (Item, Count) , according to  run-length encoding .   list(compress([ 1 ,   2 ,   2 ,   3 ,   3 ,   3 ,   4 ,   4 ,   4 ,   4 ]))  # [(1, 1), (2, 2), (3, 3), (4, 4)]    rangetools.gaps(covered, whole=(-inf, inf))  computes the uncovered ranges of the whole range  whole , given the covered ranges  covered .   list(gaps( \n     [( - inf,   0 ),   ( 0.1 ,   0.2 ),   ( 0.5 ,   0.7 ),   ( 0.6 ,   0.9 )], \n     ( 0 ,   1 )  ))  # [(0, 0.1), (0.2, 0.5), (0.9, 1)]    jsontools.flatten(data, force=False)  flattens a JSON object by returning  (Path, Value ) tuples with each path  Path  from root to each value  Value .   flatten(json . loads( \"\"\"{    \"name\": \"John\",    \"address\": {      \"streetAddress\": \"21 2nd Street\",      \"city\": \"New York\",    },    \"phoneNumbers\": [      {        \"type\": \"home\",        \"number\": \"212 555-1234\"      },      {        \"type\": \"office\",        \"number\": \"646 555-4567\"      }    ],    \"children\": [],    \"spouse\": null  }\"\"\" ))  # {'name': 'John',  #  'address.streetAddress': '21 2nd Street',  #  'address.city': 'New York',  #  'phoneNumbers[0].type': 'home',  #  'phoneNumbers[0].number': '212 555-1234',  #  'phoneNumbers[1].type': 'office',  #  'phoneNumbers[1].number': '646 555-4567',  #  'children': [],  #  'spouse': None}",
            "title": "Examples"
        },
        {
            "location": "/README/#installation",
            "text": "This package is available on PyPI. Just use  pip3 install -U extratools  to install it.",
            "title": "Installation"
        },
        {
            "location": "/README/#other-libraries",
            "text": "The following libraries are highly recommended to use together with  extratools .  toolz  sortedcontainers",
            "title": "Other Libraries"
        },
        {
            "location": "/functions/debugtools/",
            "text": "Source\n\n\nIterable\n\u00b6\n\n\nTools for debugging iterable sequence.\n\n\ndelayediter\n\u00b6\n\n\ndelayediter(seq, delay=None)\n delays the production of each item in \nseq\n by \ndelay\n seconds.\n\n\n\n\nIn default, \ndelay=None\n is disabled.\n\n\n\n\nfor\n \nv\n \nin\n \ndelayediter(range(\n5\n),\n \ndelay\n=\n1\n):\n\n    \nprint\n(datetime\n.\ndatetime\n.\nnow()\n.\ntime(),\n \nv)\n\n\n# 01:11:21.562655 0\n\n\n# 01:11:22.563725 1\n\n\n# 01:11:23.567723 2\n\n\n# 01:11:24.567997 3\n\n\n# 01:11:25.568119 4\n\n\n\n\n\n\ntimediter\n\u00b6\n\n\ntimediter(seq)\n produces each item in \nseq\n and its respective timestamp when encountered.\n\n\nfor\n \nt,\n \nv\n \nin\n \ntimediter(delayediter(range(\n5\n),\n \ndelay\n=\n1\n)):\n\n    \nprint\n(datetime\n.\ndatetime\n.\nfromtimestamp(t)\n.\ntime(),\n \nv)\n\n\n# 01:13:37.181460 0\n\n\n# 01:13:38.182715 1\n\n\n# 01:13:39.188049 2\n\n\n# 01:13:40.193304 3\n\n\n# 01:13:41.197916 4\n\n\n\n\n\n\nSystem Diagnosis\n\u00b6\n\n\nTools for non-functional but useful system diagnosis tools.\n\n\nstopwatch\n\u00b6\n\n\nstopwatch()\n returns both the duration since program start and the duration since last call in seconds.\n\n\n\n\nWarning\n\n\nThe stopwatch only starts after \ndebugtools\n is imported.\n\n\n\n\npeakmem\n\u00b6\n\n\npeakmem()\n returns the peak memory usage since program start.\n\n\n\n\nDanger\n\n\nIn bytes on macOS, and in kilobytes on Linux.",
            "title": "debugtools"
        },
        {
            "location": "/functions/debugtools/#iterable",
            "text": "Tools for debugging iterable sequence.",
            "title": "Iterable"
        },
        {
            "location": "/functions/debugtools/#delayediter",
            "text": "delayediter(seq, delay=None)  delays the production of each item in  seq  by  delay  seconds.   In default,  delay=None  is disabled.   for   v   in   delayediter(range( 5 ),   delay = 1 ): \n     print (datetime . datetime . now() . time(),   v)  # 01:11:21.562655 0  # 01:11:22.563725 1  # 01:11:23.567723 2  # 01:11:24.567997 3  # 01:11:25.568119 4",
            "title": "delayediter"
        },
        {
            "location": "/functions/debugtools/#timediter",
            "text": "timediter(seq)  produces each item in  seq  and its respective timestamp when encountered.  for   t,   v   in   timediter(delayediter(range( 5 ),   delay = 1 )): \n     print (datetime . datetime . fromtimestamp(t) . time(),   v)  # 01:13:37.181460 0  # 01:13:38.182715 1  # 01:13:39.188049 2  # 01:13:40.193304 3  # 01:13:41.197916 4",
            "title": "timediter"
        },
        {
            "location": "/functions/debugtools/#system-diagnosis",
            "text": "Tools for non-functional but useful system diagnosis tools.",
            "title": "System Diagnosis"
        },
        {
            "location": "/functions/debugtools/#stopwatch",
            "text": "stopwatch()  returns both the duration since program start and the duration since last call in seconds.   Warning  The stopwatch only starts after  debugtools  is imported.",
            "title": "stopwatch"
        },
        {
            "location": "/functions/debugtools/#peakmem",
            "text": "peakmem()  returns the peak memory usage since program start.   Danger  In bytes on macOS, and in kilobytes on Linux.",
            "title": "peakmem"
        },
        {
            "location": "/functions/dicttools/",
            "text": "Source\n\n\nDictionary Inverting\n\u00b6\n\n\nTools for inverting dictionaries.\n\n\ninvert\n\u00b6\n\n\ninvert(d)\n inverts \n(Key, Value)\n pairs to \n(Value, Key)\n.\n\n\n\n\nIf multiple keys share the same value, the inverted directory keeps last of the respective keys.\n\n\n\n\nprint\n(invert({\n1\n:\n \n'a'\n,\n \n2\n:\n \n'b'\n,\n \n3\n:\n \n'c'\n}))\n\n\n# {'a': 1, 'b': 2, 'c': 3}\n\n\n\n\n\n\ninvert_safe\n\u00b6\n\n\ninvert_safe(d)\n inverts \n(Key, Value)\n pairs to \n(Value, List[Key])\n.\n\n\n\n\nIf multiple keys share the same value, the inverted directory keeps a list of all the respective keys.\n\n\n\n\nd\n \n=\n \n{\n1\n:\n \n'a'\n,\n \n2\n:\n \n'b'\n,\n \n3\n:\n \n'a'\n}\n\n\n\nprint\n(invert(d))\n\n\n# {'a': 3, 'b': 2}\n\n\n\nprint\n(invert_safe(d))\n\n\n# {'a': [1, 3], 'b': [2]}\n\n\n\n\n\n\ninvert_multiple\n\u00b6\n\n\ninvert_multiple(d)\n inverts either \n(Key, Value)\n to \n(Value, Key)\n, or \n(Key, Iterable[Value])\n pair to multiple \n(Value, Key)\n.\n\n\n\n\nIf multiple keys share the same value, the inverted directory keeps last of the respective keys.\n\n\n\n\ninvert_multiple({\n1\n:\n \n'abc'\n,\n \n2\n:\n \n'def'\n,\n \n3\n:\n \n'ghi'\n})\n\n\n# {'a': 1, 'b': 1, 'c': 1, 'd': 2, 'e': 2, 'f': 2, 'g': 3}\n\n\n\n\n\n\nRemapping\n\u00b6\n\n\nTools for remapping elements.\n\n\nremap\n\u00b6\n\n\nremap(data, mapping, key=None)\n remaps each unique element in \ndata\n to a new value from calling function \nkey\n.\n\n\n\n\n\n\nmapping\n is a dictionary recording all the mappings, optionally containing previous mappings to reuse.\n\n\n\n\n\n\nIn default, \nkey\n returns integers starting from \n0\n.\n\n\n\n\n\n\ndocs\n \n=\n \n[\n\n    \n[\n'a'\n,\n \n'b'\n,\n \n'c'\n,\n \n'd'\n,\n \n'e'\n],\n\n    \n[\n'b'\n,\n \n'b'\n,\n \n'b'\n,\n \n'd'\n,\n \n'e'\n],\n\n    \n[\n'c'\n,\n \n'b'\n,\n \n'c'\n,\n \n'c'\n,\n \n'a'\n],\n\n    \n[\n'b'\n,\n \n'b'\n,\n \n'b'\n,\n \n'c'\n,\n \n'c'\n]\n\n\n]\n\n\n\nwordmap\n \n=\n \n{}\n\n\ndb\n \n=\n \n[list(remap(doc,\n \nwordmap))\n \nfor\n \ndoc\n \nin\n \ndocs]\n\n\n\nprint\n(db)\n\n\n# [[0, 1, 2, 3, 4],\n\n\n#  [1, 1, 1, 3, 4],\n\n\n#  [2, 1, 2, 2, 0],\n\n\n#  [1, 1, 1, 2, 2]]\n\n\n\nprint\n(wordmap)\n\n\n# {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4}\n\n\n\n\n\n\nIndexing\n\u00b6\n\n\nTools for indexing.\n\n\ninvertedindex\n\u00b6\n\n\ninvertedindex(seqs)\n creates an \ninverted index\n.\n\n\n\n\nEach item\u2019s index is a list of \n(ID, position)\n pairs for all the sequences in \nseqs\n containing the item.\n\n\n\n\ndata\n \n=\n \n[s\n.\nsplit()\n \nfor\n \ns\n \nin\n \n[\n\n    \n\"a b c d e\"\n,\n\n    \n\"b b b d e\"\n,\n\n    \n\"c b c c a\"\n,\n\n    \n\"b b b c c\"\n\n\n]]\n\n\n\ninvertedindex(data)\n\n\n# {'a': [(0, 0), (2, 4)],\n\n\n#  'b': [(0, 1), (1, 0), (2, 1), (3, 0)],\n\n\n#  'c': [(0, 2), (2, 0), (3, 3)],\n\n\n#  'd': [(0, 3), (1, 3)],\n\n\n#  'e': [(0, 4), (1, 4)]}\n\n\n\n\n\n\nnextentries\n\u00b6\n\n\nnextentries(data, entries)\n scans the sequences in \ndata\n from left to right after current entries \nentries\n, and returns each item and its respective following entries.\n\n\n\n\nEach entry is a pair of \n(ID, Position)\n denoting the sequence ID and its respective matching position.\n\n\n\n\n# same data from previous example\n\n\n\n# the first positions of `c` among sequences.\n\n\nentries\n \n=\n \n[(\n0\n,\n \n2\n),\n \n(\n2\n,\n \n0\n),\n \n(\n3\n,\n \n3\n)]\n\n\n\nnextentries(data,\n \nentries)\n\n\n# {'d': [(0, 3)],\n\n\n#  'e': [(0, 4)],\n\n\n#  'b': [(2, 1)],\n\n\n#  'c': [(2, 2), (3, 4)],\n\n\n#  'a': [(2, 4)]}\n\n\n\n\n\n\nDictionary Flatten/Unflatten\n\u00b6\n\n\nTools for flatten/unflatten a dictionary.\n\n\nflatten\n\u00b6\n\n\nflatten(d, force=False)\n flattens a dictionary by returning \n(Path, Value\n) tuples with each path \nPath\n from root to each value \nValue\n.\n\n\n\n\n\n\nFor each path, if any array with nested dictionary is encountered, the index of the array also becomes part of the path.\n\n\n\n\n\n\nIn default, only an array with nested dictionary is flatten. Instead, parameter \nforce\n can be specified to flatten any array.\n\n\n\n\n\n\n\n\nWarning\n\n\nDifferent from \njsontools.flatten\n, this function accepts only dictionary.\n\n\nAn empty dictionary disappears after being flatten. When use \nforce = True\n, an empty array disappears after being flatten.\n\n\n\n\nflatten(json\n.\nloads(\n\"\"\"{\n\n\n  \"name\": \"John\",\n\n\n  \"address\": {\n\n\n    \"streetAddress\": \"21 2nd Street\",\n\n\n    \"city\": \"New York\",\n\n\n  },\n\n\n  \"phoneNumbers\": [\n\n\n    {\n\n\n      \"type\": \"home\",\n\n\n      \"number\": \"212 555-1234\"\n\n\n    },\n\n\n    {\n\n\n      \"type\": \"office\",\n\n\n      \"number\": \"646 555-4567\"\n\n\n    }\n\n\n  ],\n\n\n  \"children\": [],\n\n\n  \"spouse\": null\n\n\n}\"\"\"\n))\n\n\n# {'name': 'John',\n\n\n#  ('address', 'streetAddress'): '21 2nd Street',\n\n\n#  ('address', 'city'): 'New York',\n\n\n#  (('phoneNumbers', 0), 'type'): 'home',\n\n\n#  (('phoneNumbers', 0), 'number'): '212 555-1234',\n\n\n#  (('phoneNumbers', 1), 'type'): 'office',\n\n\n#  (('phoneNumbers', 1), 'number'): '646 555-4567',\n\n\n#  'children': [],\n\n\n#  'spouse': None}",
            "title": "dicttools"
        },
        {
            "location": "/functions/dicttools/#dictionary-inverting",
            "text": "Tools for inverting dictionaries.",
            "title": "Dictionary Inverting"
        },
        {
            "location": "/functions/dicttools/#invert",
            "text": "invert(d)  inverts  (Key, Value)  pairs to  (Value, Key) .   If multiple keys share the same value, the inverted directory keeps last of the respective keys.   print (invert({ 1 :   'a' ,   2 :   'b' ,   3 :   'c' }))  # {'a': 1, 'b': 2, 'c': 3}",
            "title": "invert"
        },
        {
            "location": "/functions/dicttools/#invert_safe",
            "text": "invert_safe(d)  inverts  (Key, Value)  pairs to  (Value, List[Key]) .   If multiple keys share the same value, the inverted directory keeps a list of all the respective keys.   d   =   { 1 :   'a' ,   2 :   'b' ,   3 :   'a' }  print (invert(d))  # {'a': 3, 'b': 2}  print (invert_safe(d))  # {'a': [1, 3], 'b': [2]}",
            "title": "invert_safe"
        },
        {
            "location": "/functions/dicttools/#invert_multiple",
            "text": "invert_multiple(d)  inverts either  (Key, Value)  to  (Value, Key) , or  (Key, Iterable[Value])  pair to multiple  (Value, Key) .   If multiple keys share the same value, the inverted directory keeps last of the respective keys.   invert_multiple({ 1 :   'abc' ,   2 :   'def' ,   3 :   'ghi' })  # {'a': 1, 'b': 1, 'c': 1, 'd': 2, 'e': 2, 'f': 2, 'g': 3}",
            "title": "invert_multiple"
        },
        {
            "location": "/functions/dicttools/#remapping",
            "text": "Tools for remapping elements.",
            "title": "Remapping"
        },
        {
            "location": "/functions/dicttools/#remap",
            "text": "remap(data, mapping, key=None)  remaps each unique element in  data  to a new value from calling function  key .    mapping  is a dictionary recording all the mappings, optionally containing previous mappings to reuse.    In default,  key  returns integers starting from  0 .    docs   =   [ \n     [ 'a' ,   'b' ,   'c' ,   'd' ,   'e' ], \n     [ 'b' ,   'b' ,   'b' ,   'd' ,   'e' ], \n     [ 'c' ,   'b' ,   'c' ,   'c' ,   'a' ], \n     [ 'b' ,   'b' ,   'b' ,   'c' ,   'c' ]  ]  wordmap   =   {}  db   =   [list(remap(doc,   wordmap))   for   doc   in   docs]  print (db)  # [[0, 1, 2, 3, 4],  #  [1, 1, 1, 3, 4],  #  [2, 1, 2, 2, 0],  #  [1, 1, 1, 2, 2]]  print (wordmap)  # {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4}",
            "title": "remap"
        },
        {
            "location": "/functions/dicttools/#indexing",
            "text": "Tools for indexing.",
            "title": "Indexing"
        },
        {
            "location": "/functions/dicttools/#invertedindex",
            "text": "invertedindex(seqs)  creates an  inverted index .   Each item\u2019s index is a list of  (ID, position)  pairs for all the sequences in  seqs  containing the item.   data   =   [s . split()   for   s   in   [ \n     \"a b c d e\" , \n     \"b b b d e\" , \n     \"c b c c a\" , \n     \"b b b c c\"  ]]  invertedindex(data)  # {'a': [(0, 0), (2, 4)],  #  'b': [(0, 1), (1, 0), (2, 1), (3, 0)],  #  'c': [(0, 2), (2, 0), (3, 3)],  #  'd': [(0, 3), (1, 3)],  #  'e': [(0, 4), (1, 4)]}",
            "title": "invertedindex"
        },
        {
            "location": "/functions/dicttools/#nextentries",
            "text": "nextentries(data, entries)  scans the sequences in  data  from left to right after current entries  entries , and returns each item and its respective following entries.   Each entry is a pair of  (ID, Position)  denoting the sequence ID and its respective matching position.   # same data from previous example  # the first positions of `c` among sequences.  entries   =   [( 0 ,   2 ),   ( 2 ,   0 ),   ( 3 ,   3 )]  nextentries(data,   entries)  # {'d': [(0, 3)],  #  'e': [(0, 4)],  #  'b': [(2, 1)],  #  'c': [(2, 2), (3, 4)],  #  'a': [(2, 4)]}",
            "title": "nextentries"
        },
        {
            "location": "/functions/dicttools/#dictionary-flattenunflatten",
            "text": "Tools for flatten/unflatten a dictionary.",
            "title": "Dictionary Flatten/Unflatten"
        },
        {
            "location": "/functions/dicttools/#flatten",
            "text": "flatten(d, force=False)  flattens a dictionary by returning  (Path, Value ) tuples with each path  Path  from root to each value  Value .    For each path, if any array with nested dictionary is encountered, the index of the array also becomes part of the path.    In default, only an array with nested dictionary is flatten. Instead, parameter  force  can be specified to flatten any array.     Warning  Different from  jsontools.flatten , this function accepts only dictionary.  An empty dictionary disappears after being flatten. When use  force = True , an empty array disappears after being flatten.   flatten(json . loads( \"\"\"{    \"name\": \"John\",    \"address\": {      \"streetAddress\": \"21 2nd Street\",      \"city\": \"New York\",    },    \"phoneNumbers\": [      {        \"type\": \"home\",        \"number\": \"212 555-1234\"      },      {        \"type\": \"office\",        \"number\": \"646 555-4567\"      }    ],    \"children\": [],    \"spouse\": null  }\"\"\" ))  # {'name': 'John',  #  ('address', 'streetAddress'): '21 2nd Street',  #  ('address', 'city'): 'New York',  #  (('phoneNumbers', 0), 'type'): 'home',  #  (('phoneNumbers', 0), 'number'): '212 555-1234',  #  (('phoneNumbers', 1), 'type'): 'office',  #  (('phoneNumbers', 1), 'number'): '646 555-4567',  #  'children': [],  #  'spouse': None}",
            "title": "flatten"
        },
        {
            "location": "/functions/jsontools/",
            "text": "Source\n\n\nJSON Flatten/Unflatten\n\u00b6\n\n\nTools for flatten/unflatten a JSON object.\n\n\nflatten\n\u00b6\n\n\nflatten(data, force=False)\n flattens a JSON object by returning \n(Path, Value\n) tuples with each path \nPath\n from root to each value \nValue\n.\n\n\n\n\n\n\nFor each path, if any array with nested dictionary is encountered, the index of the array also becomes part of the path.\n\n\n\n\n\n\nIn default, only an array with nested dictionary is flatten. Instead, parameter \nforce\n can be specified to flatten any array.\n\n\n\n\n\n\n\n\nInfo\n\n\nDifferent from \ndicttools.flatten\n, this function accepts any JSON object not limited to dictionary.\n\n\n\n\n\n\nWarning\n\n\nAn empty dictionary disappears after being flatten. When use \nforce = True\n, an empty array disappears after being flatten.\n\n\n\n\nflatten(json\n.\nloads(\n\"\"\"{\n\n\n  \"name\": \"John\",\n\n\n  \"address\": {\n\n\n    \"streetAddress\": \"21 2nd Street\",\n\n\n    \"city\": \"New York\",\n\n\n  },\n\n\n  \"phoneNumbers\": [\n\n\n    {\n\n\n      \"type\": \"home\",\n\n\n      \"number\": \"212 555-1234\"\n\n\n    },\n\n\n    {\n\n\n      \"type\": \"office\",\n\n\n      \"number\": \"646 555-4567\"\n\n\n    }\n\n\n  ],\n\n\n  \"children\": [],\n\n\n  \"spouse\": null\n\n\n}\"\"\"\n))\n\n\n# {'name': 'John',\n\n\n#  'address.streetAddress': '21 2nd Street',\n\n\n#  'address.city': 'New York',\n\n\n#  'phoneNumbers[0].type': 'home',\n\n\n#  'phoneNumbers[0].number': '212 555-1234',\n\n\n#  'phoneNumbers[1].type': 'office',\n\n\n#  'phoneNumbers[1].number': '646 555-4567',\n\n\n#  'children': [],\n\n\n#  'spouse': None}",
            "title": "jsontools"
        },
        {
            "location": "/functions/jsontools/#json-flattenunflatten",
            "text": "Tools for flatten/unflatten a JSON object.",
            "title": "JSON Flatten/Unflatten"
        },
        {
            "location": "/functions/jsontools/#flatten",
            "text": "flatten(data, force=False)  flattens a JSON object by returning  (Path, Value ) tuples with each path  Path  from root to each value  Value .    For each path, if any array with nested dictionary is encountered, the index of the array also becomes part of the path.    In default, only an array with nested dictionary is flatten. Instead, parameter  force  can be specified to flatten any array.     Info  Different from  dicttools.flatten , this function accepts any JSON object not limited to dictionary.    Warning  An empty dictionary disappears after being flatten. When use  force = True , an empty array disappears after being flatten.   flatten(json . loads( \"\"\"{    \"name\": \"John\",    \"address\": {      \"streetAddress\": \"21 2nd Street\",      \"city\": \"New York\",    },    \"phoneNumbers\": [      {        \"type\": \"home\",        \"number\": \"212 555-1234\"      },      {        \"type\": \"office\",        \"number\": \"646 555-4567\"      }    ],    \"children\": [],    \"spouse\": null  }\"\"\" ))  # {'name': 'John',  #  'address.streetAddress': '21 2nd Street',  #  'address.city': 'New York',  #  'phoneNumbers[0].type': 'home',  #  'phoneNumbers[0].number': '212 555-1234',  #  'phoneNumbers[1].type': 'office',  #  'phoneNumbers[1].number': '646 555-4567',  #  'children': [],  #  'spouse': None}",
            "title": "flatten"
        },
        {
            "location": "/functions/mathtools/",
            "text": "Source\n\n\nTools for math.\n\n\nsafediv\n\u00b6\n\n\nsafediv(a, b)\n avoids the \ndivision by zero\n exception, by returning infinite with proper sign.\n\n\n\n\nInfo\n\n\nClosely referring \nIEEE Standard 754\n.\n\n\n\n\nsafediv(\n0\n,\n \n0\n)\n\n\n# nan\n\n\n\nsafediv(\n1\n,\n \n0\n)\n\n\n# inf\n\n\n\nsafediv(\n-\n1\n,\n \n0\n)\n\n\n# -inf\n\n\n\nsafediv(\n1\n,\n \n1\n)\n\n\n# 1.0\n\n\n\n\n\n\nproduct\n\u00b6\n\n\nproduct(*nums)\n computes the product of all the numbers in \nnums\n.\n\n\nproduct(\n*\n(\n0.1\n \n*\n \nn\n \nfor\n \nn\n \nin\n \nrange(\n1\n,\n \n101\n)))\n\n\n# 9.332621544394479e+57",
            "title": "mathtools"
        },
        {
            "location": "/functions/mathtools/#safediv",
            "text": "safediv(a, b)  avoids the  division by zero  exception, by returning infinite with proper sign.   Info  Closely referring  IEEE Standard 754 .   safediv( 0 ,   0 )  # nan  safediv( 1 ,   0 )  # inf  safediv( - 1 ,   0 )  # -inf  safediv( 1 ,   1 )  # 1.0",
            "title": "safediv"
        },
        {
            "location": "/functions/mathtools/#product",
            "text": "product(*nums)  computes the product of all the numbers in  nums .  product( * ( 0.1   *   n   for   n   in   range( 1 ,   101 )))  # 9.332621544394479e+57",
            "title": "product"
        },
        {
            "location": "/functions/misctools/",
            "text": "Source\n\n\nTools for miscellaneous purposes.\n\n\ncmp\n\u00b6\n\n\ncmp(a, b)\n restores the useful \ncmp\n function previously in Python 2.\n\n\n\n\nInfo\n\n\nImplemented according to \nWhat\u2019s New in Python 3.0\n.\n\n\n\n\nparsebool\n\u00b6\n\n\nparsebool(s)\n parses a string to boolean, if its lowercase equals to \n1\n, \ntrue\n, \nyes\n, etc.\n\n\n\n\nTip\n\n\nCheck the full list of acceptable strings in \nSource\n.",
            "title": "misctools"
        },
        {
            "location": "/functions/misctools/#cmp",
            "text": "cmp(a, b)  restores the useful  cmp  function previously in Python 2.   Info  Implemented according to  What\u2019s New in Python 3.0 .",
            "title": "cmp"
        },
        {
            "location": "/functions/misctools/#parsebool",
            "text": "parsebool(s)  parses a string to boolean, if its lowercase equals to  1 ,  true ,  yes , etc.   Tip  Check the full list of acceptable strings in  Source .",
            "title": "parsebool"
        },
        {
            "location": "/functions/printtools/",
            "text": "Source\n\n\nPrinting\n\u00b6\n\n\nTools for controlling printing destination.\n\n\nprint2\n\u00b6\n\n\nprint2(*args, **kwargs)\n redirects the output of \nprint\n to standard error.\n\n\n\n\nTip\n\n\nThe same parameters of builtin \nprint\n are accepted.\n\n\n\n\nTo String\n\u00b6\n\n\nTools for generating the intuitive string representation.\n\n\n\n\nInfo\n\n\nBuiltin function \nrepr\n is used to print each item safely.\n\n\n\n\niter2str\n\u00b6\n\n\niter2str(seq, limit=None)\n converts an iterable sequence to string.\n\n\n\n\nIf \nlimit\n is specified, only print the first \nlimit\n items. This is useful when \nseq\n is an infinite sequence.\n\n\n\n\niter2str(range(\n5\n))\n\n\n# '<0, 1, 2, 3, 4>'\n\n\n\n# Infinity sequence\n\n\niter2str(itertools\n.\ncount(),\n \nlimit\n=\n5\n)\n\n\n# '<0, 1, 2, 3, 4, ...>'\n\n\n\n\n\n\nalignment2str\n\u00b6\n\n\nalignment2str(*seqs, default=None, separator=' ')\n prints the alignment between sequences \nseq\n. \ndefault=None\n is used for labelling missing value from each sequences.\n\n\n\n\n\n\nseparator\n can be specified to separate every two values.\n\n\n\n\n\n\nIf sequences have different lengths, the extra trailing items are also printed as not matching.\n\n\n\n\n\n\n\n\nTip\n\n\nseqtools.align\n can compute the alignment between two sequences.\n\n\n\n\nprint\n(alignment2str(\n\n    \n[\n1\n,\n \n10\n,\n  \n100\n,\n \n\"New York\"\n],\n\n    \n[\n1\n,\n \n10\n,\n \nNone,\n \n\"New York\"\n]\n\n\n))\n\n\n# 1 10 100 'New York'\n\n\n# 1 10     'New York'\n\n\n\nprint\n(alignment2str(\n*\nalign(\n\n    \n[\n1\n,\n \n10\n,\n \n100\n,\n \n\"New York\"\n],\n\n    \n[\n1\n,\n \n10\n,\n      \n\"New York\"\n]\n\n\n)[\n1\n]))\n\n\n# 1 10 100 'New York'\n\n\n# 1 10     'New York'\n\n\n\nprint\n(alignment2str(\n\n    \n[\n1\n,\n \n10\n,\n \n100\n,\n \n\"New York\"\n],\n\n    \n[\n1\n,\n \n10\n,\n \n100\n]\n\n\n))\n\n\n# 1 10 100 'New York'\n\n\n# 1 10 100     \n\n\n\n\n\n\ntable2str\n\u00b6\n\n\ntable2str(data, default=None, separator=\" | \")\n a thin wrapper of \nalignment2str\n to print a row-based table.\n\n\n\n\nTip\n\n\nThe default output format is compatible to \nMarkdown\n format.\n\n\n\n\nprint\n(table2str([\n\n    \n[\n1\n,\n   \n10\n,\n  \n100\n,\n \n\"New York\"\n],\n\n    \n[\n1\n,\n   \n10\n,\n \nNone,\n \n\"New York\"\n],\n\n    \n[\n1\n,\n \nNone,\n  \n100\n,\n \n\"New York\"\n],\n\n    \n[\n1\n,\n   \n10\n,\n  \n100\n,\n \n\"New York\"\n]\n\n\n]))\n\n\n# 1 | 10 | 100 | 'New York'\n\n\n# 1 | 10 |     | 'New York'\n\n\n# 1 |    | 100 | 'New York'\n\n\n# 1 | 10 | 100 | 'New York'\n\n\n\n\n\n\nrange2str\n\u00b6\n\n\nrange2str(r)\n prints a range \nr\n.\n\n\nprint\n(range2str((\n0\n,\n \n1\n)))\n\n\n# [0, 1)\n\n\n\n\n\n\nsorted2str\n\u00b6\n\n\nsorted2str(seq, key=None)\n prints a sorted sequence \nseq\n, optionally according to the key function \nkey\n.\n\n\nprint\n(sorted2str([\n1\n,\n \n2\n,\n \n2\n,\n \n3\n]))\n\n\n# 1 <= 2 == 2 <= 3",
            "title": "printtools"
        },
        {
            "location": "/functions/printtools/#printing",
            "text": "Tools for controlling printing destination.",
            "title": "Printing"
        },
        {
            "location": "/functions/printtools/#print2",
            "text": "print2(*args, **kwargs)  redirects the output of  print  to standard error.   Tip  The same parameters of builtin  print  are accepted.",
            "title": "print2"
        },
        {
            "location": "/functions/printtools/#to-string",
            "text": "Tools for generating the intuitive string representation.   Info  Builtin function  repr  is used to print each item safely.",
            "title": "To String"
        },
        {
            "location": "/functions/printtools/#iter2str",
            "text": "iter2str(seq, limit=None)  converts an iterable sequence to string.   If  limit  is specified, only print the first  limit  items. This is useful when  seq  is an infinite sequence.   iter2str(range( 5 ))  # '<0, 1, 2, 3, 4>'  # Infinity sequence  iter2str(itertools . count(),   limit = 5 )  # '<0, 1, 2, 3, 4, ...>'",
            "title": "iter2str"
        },
        {
            "location": "/functions/printtools/#alignment2str",
            "text": "alignment2str(*seqs, default=None, separator=' ')  prints the alignment between sequences  seq .  default=None  is used for labelling missing value from each sequences.    separator  can be specified to separate every two values.    If sequences have different lengths, the extra trailing items are also printed as not matching.     Tip  seqtools.align  can compute the alignment between two sequences.   print (alignment2str( \n     [ 1 ,   10 ,    100 ,   \"New York\" ], \n     [ 1 ,   10 ,   None,   \"New York\" ]  ))  # 1 10 100 'New York'  # 1 10     'New York'  print (alignment2str( * align( \n     [ 1 ,   10 ,   100 ,   \"New York\" ], \n     [ 1 ,   10 ,        \"New York\" ]  )[ 1 ]))  # 1 10 100 'New York'  # 1 10     'New York'  print (alignment2str( \n     [ 1 ,   10 ,   100 ,   \"New York\" ], \n     [ 1 ,   10 ,   100 ]  ))  # 1 10 100 'New York'  # 1 10 100",
            "title": "alignment2str"
        },
        {
            "location": "/functions/printtools/#table2str",
            "text": "table2str(data, default=None, separator=\" | \")  a thin wrapper of  alignment2str  to print a row-based table.   Tip  The default output format is compatible to  Markdown  format.   print (table2str([ \n     [ 1 ,     10 ,    100 ,   \"New York\" ], \n     [ 1 ,     10 ,   None,   \"New York\" ], \n     [ 1 ,   None,    100 ,   \"New York\" ], \n     [ 1 ,     10 ,    100 ,   \"New York\" ]  ]))  # 1 | 10 | 100 | 'New York'  # 1 | 10 |     | 'New York'  # 1 |    | 100 | 'New York'  # 1 | 10 | 100 | 'New York'",
            "title": "table2str"
        },
        {
            "location": "/functions/printtools/#range2str",
            "text": "range2str(r)  prints a range  r .  print (range2str(( 0 ,   1 )))  # [0, 1)",
            "title": "range2str"
        },
        {
            "location": "/functions/printtools/#sorted2str",
            "text": "sorted2str(seq, key=None)  prints a sorted sequence  seq , optionally according to the key function  key .  print (sorted2str([ 1 ,   2 ,   2 ,   3 ]))  # 1 <= 2 == 2 <= 3",
            "title": "sorted2str"
        },
        {
            "location": "/functions/rangetools/",
            "text": "Source\n\n\n\n\nWarning\n\n\nEach range is closed on the left side, and open on the right side.\n\n\n\n\nRange Statistics\n\u00b6\n\n\nTools for statistics over ranges.\n\n\nhistogram\n\u00b6\n\n\nhistogram(thresholds, data, leftmost=-inf)\n computes the \nhistogram\n over all the floats in \ndata\n.\n\n\n\n\n\n\nThe search space is divided by the thresholds of bins specified in \nthresholds\n.\n\n\n\n\n\n\nEach bin of the histogram is labelled by its lower threshold.\n\n\n\n\n\n\nAll values in the bin are no less than the current threshold and less than the next threshold.\n\n\n\n\n\n\nThe first bin is labelled by \nleftmost\n, which is \n-inf\n in default.\n\n\n\n\n\n\n\n\n\n\n\n\nDanger\n\n\nthresholds\n must be a sorted list.\n\n\n\n\nhistogram(\n\n    \n[\n   \n0.1\n,\n                \n0.5\n,\n           \n0.8\n,\n \n0.9\n],\n\n    \n[\n0\n,\n \n0.1\n,\n \n0.2\n,\n \n0.3\n,\n \n0.4\n,\n \n0.5\n,\n \n0.6\n,\n \n0.7\n,\n \n0.8\n,\n \n0.9\n,\n \n1\n]\n\n\n)\n\n\n# {-inf: 1, 0.1: 4, 0.5: 3, 0.8: 1, 0.9: 2}\n\n\n\n\n\n\nRange Querying\n\u00b6\n\n\nTools for querying ranges.\n\n\nrangequery\n\u00b6\n\n\nrangequery(keyvalues, query, func=min)\n efficiently finds the best value from the covered values in \nkeyvalues\n, if each key in \nkeyvalues\n is within the query range \nquery\n.\n\n\n\n\nfunc\n defines how the best value is computed, and defaults to \nmin\n for minimum value.\n\n\n\n\n\n\nInfo\n\n\nImplemented by \nSegmentTree\n to solve the \nrange minimum query\n problem.\n\n\n\n\nrangequery(\n\n    \n{\n0.1\n:\n \n1\n,\n \n0.2\n:\n \n3\n,\n \n0.3\n:\n \n0\n},\n\n            \n(\n0.2\n,\n            \n0.4\n)\n\n\n)\n\n\n# 0\n\n\n\n\n\n\nRange Transformation\n\u00b6\n\n\nTools for transformations over ranges.\n\n\nintersect\n\u00b6\n\n\nintersect(a, b, allowempty=False)\n computes the overlapping of two ranges \na\n and \nb\n. Returns \nNone\n if there is no overlapping.\n\n\n\n\nallowempty\n specifies whether empty range is returned.\n\n\n\n\nintersect((\n0\n,\n \n0.6\n),\n \n(\n0.4\n,\n \n1\n))\n\n\n# (0.4, 0.6)\n\n\n\n\n\n\nunion\n\u00b6\n\n\nunion(a, b)\n computes the merging of two ranges \na\n and \nb\n. Returns \nNone\n if there is no overlapping.\n\n\nunion((\n0\n,\n \n0.6\n),\n \n(\n0.4\n,\n \n1\n))\n\n\n# (0, 1)\n\n\n\n\n\n\nrangecover\n\u00b6\n\n\nrangecover(whole, covered)\n solves the variation of the \nset cover problem\n by covering the universe range \nwhole\n as best as possible, using a subset of the covering ranges \ncovered\n.\n\n\n\n\nWarning\n\n\nThis is an approximate algorithm, which means the returned result is not always the best.\n\n\n\n\nlist(rangecover(\n\n     \n(\n0\n,\n                                                 \n1\n),\n\n    \n[(\n0\n,\n \n0.4\n),\n \n(\n0.2\n,\n \n0.5\n),\n \n(\n0.5\n,\n \n0.8\n),\n \n(\n0.6\n,\n \n0.9\n),\n \n(\n0.8\n,\n \n1\n)]\n\n\n))\n\n\n# [(0, 0.4), (0.5, 0.8), (0.8, 1), (0.2, 0.5)]\n\n\n\n\n\n\ncovers\n\u00b6\n\n\ncovers(covered)\n merges the covered ranges \ncovered\n to resolve any overlap.\n\n\n\n\nDanger\n\n\nCovered ranges in \ncovered\n must be sorted by the left side of each range.\n\n\n\n\nlist(covers([(\n-\ninf,\n \n0\n),\n \n(\n0.1\n,\n \n0.2\n),\n \n(\n0.5\n,\n \n0.7\n),\n \n(\n0.6\n,\n \n0.9\n)]))\n\n\n# [(-inf, 0), (0.1, 0.2), (0.5, 0.9)]\n\n\n\n\n\n\ngaps\n\u00b6\n\n\ngaps(covered, whole=(-inf, inf))\n computes the uncovered ranges of the whole range \nwhole\n, given the covered ranges \ncovered\n.\n\n\n\n\nDanger\n\n\nCovered ranges in \ncovered\n must be sorted by the left side of each range.\n\n\n\n\n\n\nInfo\n\n\nOverlaps among covered ranges \ncovered\n are resolved, like \ncovers(covered)\n.\n\n\n\n\nlist(gaps(\n\n    \n[(\n-\ninf,\n \n0\n),\n \n(\n0.1\n,\n \n0.2\n),\n \n(\n0.5\n,\n \n0.7\n),\n \n(\n0.6\n,\n \n0.9\n)],\n\n           \n(\n0\n,\n                                     \n1\n)\n\n\n))\n\n\n# [(0, 0.1), (0.2, 0.5), (0.9, 1)]",
            "title": "rangetools"
        },
        {
            "location": "/functions/rangetools/#range-statistics",
            "text": "Tools for statistics over ranges.",
            "title": "Range Statistics"
        },
        {
            "location": "/functions/rangetools/#histogram",
            "text": "histogram(thresholds, data, leftmost=-inf)  computes the  histogram  over all the floats in  data .    The search space is divided by the thresholds of bins specified in  thresholds .    Each bin of the histogram is labelled by its lower threshold.    All values in the bin are no less than the current threshold and less than the next threshold.    The first bin is labelled by  leftmost , which is  -inf  in default.       Danger  thresholds  must be a sorted list.   histogram( \n     [     0.1 ,                  0.5 ,             0.8 ,   0.9 ], \n     [ 0 ,   0.1 ,   0.2 ,   0.3 ,   0.4 ,   0.5 ,   0.6 ,   0.7 ,   0.8 ,   0.9 ,   1 ]  )  # {-inf: 1, 0.1: 4, 0.5: 3, 0.8: 1, 0.9: 2}",
            "title": "histogram"
        },
        {
            "location": "/functions/rangetools/#range-querying",
            "text": "Tools for querying ranges.",
            "title": "Range Querying"
        },
        {
            "location": "/functions/rangetools/#rangequery",
            "text": "rangequery(keyvalues, query, func=min)  efficiently finds the best value from the covered values in  keyvalues , if each key in  keyvalues  is within the query range  query .   func  defines how the best value is computed, and defaults to  min  for minimum value.    Info  Implemented by  SegmentTree  to solve the  range minimum query  problem.   rangequery( \n     { 0.1 :   1 ,   0.2 :   3 ,   0.3 :   0 }, \n             ( 0.2 ,              0.4 )  )  # 0",
            "title": "rangequery"
        },
        {
            "location": "/functions/rangetools/#range-transformation",
            "text": "Tools for transformations over ranges.",
            "title": "Range Transformation"
        },
        {
            "location": "/functions/rangetools/#intersect",
            "text": "intersect(a, b, allowempty=False)  computes the overlapping of two ranges  a  and  b . Returns  None  if there is no overlapping.   allowempty  specifies whether empty range is returned.   intersect(( 0 ,   0.6 ),   ( 0.4 ,   1 ))  # (0.4, 0.6)",
            "title": "intersect"
        },
        {
            "location": "/functions/rangetools/#union",
            "text": "union(a, b)  computes the merging of two ranges  a  and  b . Returns  None  if there is no overlapping.  union(( 0 ,   0.6 ),   ( 0.4 ,   1 ))  # (0, 1)",
            "title": "union"
        },
        {
            "location": "/functions/rangetools/#rangecover",
            "text": "rangecover(whole, covered)  solves the variation of the  set cover problem  by covering the universe range  whole  as best as possible, using a subset of the covering ranges  covered .   Warning  This is an approximate algorithm, which means the returned result is not always the best.   list(rangecover( \n      ( 0 ,                                                   1 ), \n     [( 0 ,   0.4 ),   ( 0.2 ,   0.5 ),   ( 0.5 ,   0.8 ),   ( 0.6 ,   0.9 ),   ( 0.8 ,   1 )]  ))  # [(0, 0.4), (0.5, 0.8), (0.8, 1), (0.2, 0.5)]",
            "title": "rangecover"
        },
        {
            "location": "/functions/rangetools/#covers",
            "text": "covers(covered)  merges the covered ranges  covered  to resolve any overlap.   Danger  Covered ranges in  covered  must be sorted by the left side of each range.   list(covers([( - inf,   0 ),   ( 0.1 ,   0.2 ),   ( 0.5 ,   0.7 ),   ( 0.6 ,   0.9 )]))  # [(-inf, 0), (0.1, 0.2), (0.5, 0.9)]",
            "title": "covers"
        },
        {
            "location": "/functions/rangetools/#gaps",
            "text": "gaps(covered, whole=(-inf, inf))  computes the uncovered ranges of the whole range  whole , given the covered ranges  covered .   Danger  Covered ranges in  covered  must be sorted by the left side of each range.    Info  Overlaps among covered ranges  covered  are resolved, like  covers(covered) .   list(gaps( \n     [( - inf,   0 ),   ( 0.1 ,   0.2 ),   ( 0.5 ,   0.7 ),   ( 0.6 ,   0.9 )], \n            ( 0 ,                                       1 )  ))  # [(0, 0.1), (0.2, 0.5), (0.9, 1)]",
            "title": "gaps"
        },
        {
            "location": "/functions/seqtools/",
            "text": "Source\n\n\n\n\nWarning\n\n\nFor tools specific to sub-sequence without gap, please go to specific \ndocumentation\n.\n\n\nFor tools specific to sub-sequence with gap, please go to specific \ndocumentation\n.\n\n\n\n\n\n\nSuccess\n\n\nIf not explicitly noted, a sequence refers to not only list, tuple, string, or \narray\n, but any iterable.\n\n\nIf not explicitly noted, a function is lazy, where each sequence is processed incrmentally only when necessary and returned incrmentally as a generator.\n\n\n\n\n\n\nInfo\n\n\nEmpty sequence is always a sub-sequence of any other sequence.\n\n\nA sequence is always a sub-sequence of itself.\n\n\n\n\nSequence Matching\n\u00b6\n\n\nmatchingfrequencies\n\u00b6\n\n\nmatchingfrequencies(*seqs, key=None)\n returns each item and the respective number of sequences in \nseqs\n contains it.\n\n\n\n\nOptional key function \nkey\n can be specified.\n\n\n\n\n\n\nTip\n\n\nIf each sequence is sorted, then optimized \nsortedtools.matchingfrequencies\n with the same API should be used for better efficiency.\n\n\nFor the frequency of each item within a single sequence, use \ntoolz.itertoolz.frequencies\n.\n\n\n\n\nlist(matchingfrequencies(\n\n    \n[\n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n],\n\n    \n[\n1\n,\n \n1\n,\n \n1\n,\n \n3\n,\n \n4\n],\n\n    \n[\n2\n,\n \n1\n,\n \n2\n,\n \n2\n,\n \n0\n],\n\n    \n[\n1\n,\n \n1\n,\n \n1\n,\n \n2\n,\n \n2\n]\n\n\n))\n\n\n# [(0, 2), (1, 4), (2, 3), (3, 2), (4, 2)]\n\n\n\n\n\n\nSequence Alignment and Join\n\u00b6\n\n\nTools for aligning and joining sequences.\n\n\nmatch\n\u00b6\n\n\nmatch(a, b, default=None)\n matches two sequences \na\n and \nb\n in pairs, such that the total number of matching pairs is maximized.\n\n\n\n\nIf there are multiple alignments having the same number, the leftmost one is returned.\n\n\n\n\n\n\nWarning\n\n\nThis function reads all sequences at once.\n\n\n\n\n\n\nTip\n\n\nIf both two sequences are sorted, respectively, then optimized \nsortedtools.sortedmatch\n with the same API should be used for better efficiency.\n\n\n\n\nlist(match(\n\n    \n[\n0\n,\n    \n1\n,\n \n1\n,\n \n0\n,\n \n1\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n1\n,\n    \n1\n]\n\n\n))\n\n\n# [(0, 0),\n\n\n#  (None, 0),\n\n\n#  (1, 1),\n\n\n#  (1, 1),\n\n\n#  (0, None),\n\n\n#  (1, 1)]\n\n\n\n\n\n\nalign\n\u00b6\n\n\nalign(a, b, cost=None, bound=inf, default=None)\n computes the \nalignment\n two sequences \na\n and \nb\n, such that the total cost of the aligned sequences given the pair-wise cost function \ncost(x, y)\n is minimized.\n\n\n\n\n\n\nAssume the sequences after alignment are \na'\n and \nb'\n. The total cost is \nsum(cost(x, y) for x, y in zip(a', b'))\n.\n\n\n\n\n\n\nBoth the minimum total cost and the respective aligned sequences are returned as a tuple.\n\n\n\n\n\n\nIn default, the cost function \ncost(x, y)\n returns \n0\n when \nx == y\n and \n1\n when not. This is equal to the \nedit distance\n.\n\n\n\n\n\n\nTo speedup the computation, a threshold of maximum cost \nbound=inf\n can be specified. When there is no satisfying result, \nNone\n is returned.\n\n\n\n\n\n\nIf there are multiple alignments having the same cost, the leftmost one is returned.\n\n\n\n\n\n\n\n\nWarning\n\n\nThis function reads all sequences at once.\n\n\n\n\nalign(\n\n    \n[\n0\n,\n    \n1\n,\n \n1\n,\n \n0\n,\n \n1\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n1\n,\n    \n1\n]\n\n\n)\n\n\n# (2, ([0, None, 1, 1,    0, 1],\n\n\n#      [0,    0, 1, 1, None, 1]))\n\n\n\nalign(\n\n    \n[\n0\n,\n    \n1\n,\n \n1\n,\n \n0\n,\n \n1\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n1\n,\n    \n1\n],\n\n    \nbound\n=\n1\n\n\n)\n\n\n# None\n\n\n\n\n\n\njoin\n\u00b6\n\n\njoin(leftseq, rightseq, leftkey=None, rightkey=None, leftdefault=no_default, rightdefault=no_default)\n joins two sequences, optionally according to \nleftkey\n and \nrightkey\n, respectively. Outer join is also supported.\n\n\n\n\nWarning\n\n\nThis function reads the first sequence at once.\n\n\n\n\n\n\nTip\n\n\nIf both two sequences are sorted according to \nleftkey\n and \nrightkey\n, respectively, then optimized \nsortedtools.sortedjoin\n with the same API should be used for better efficiency.\n\n\n\n\n\n\nInfo\n\n\njoin\n is just a wrapper of \ntoolz.itertools.join\n with the same more friendly API of \nsortedtools.sortedjoin\n.\n\n\n\n\nlist(join(\n\n    \n[\n   \n-\n1\n,\n \n-\n1\n,\n \n-\n2\n,\n    \n-\n4\n,\n \n-\n5\n,\n    \n-\n6\n],\n\n    \n[\n0\n,\n  \n1\n,\n  \n1\n,\n  \n2\n,\n \n3\n,\n  \n4\n,\n  \n5\n,\n \n5\n],\n\n    \nleftkey\n=\nabs,\n \nleftdefault\n=\nNone\n\n\n))\n\n\n# [(None, 0),\n\n\n#  (-1, 1),\n\n\n#  (-1, 1),\n\n\n#  (-1, 1),\n\n\n#  (-1, 1),\n\n\n#  (-2, 2),\n\n\n#  (None, 3),\n\n\n#  (-4, 4),\n\n\n#  (-5, 5),\n\n\n#  (-5, 5)]\n\n\n\n\n\n\ntemplateseq\n\u00b6\n\n\ntemplateseq(seqs, default=None, simple=True)\n finds the common template of all the sequences \nseqs\n. \ndefault=None\n is used to denote any placeholder sub-sequence.\n\n\n\n\n\n\nFor better performance, option \nsimple\n is enabled in default for only one scan of the sequences. However, it may work incorrectly for more complex template, which is:\n\n\n\n\n\n\nAny part of the template appears more than once in the same sequence,\n\n\n\n\n\n\nAny part of the template does not always appear before or after than another according to the same order part among sequences.\n\n\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\nThis function reads all the sequences at once.\n\n\nThis function reads all the sequences more than once when \nsimple = False\n.\n\n\n\n\n\n\nTip\n\n\nEssentially, each template is a closed sequential pattern covering all the sequences. Please check \nPrefixSpan-Py\n for more advanced scenarios.\n\n\n\n\nlist(templateseq((\n\n    \ns\n.\nsplit()\n \nfor\n \ns\n \nin\n \n[\n\n        \n\"Alice likes tea and coffee !\"\n,\n\n        \n\"Bob likes sushi and ramen !\"\n,\n\n        \n\"Elisa or Anna likes icecream and cake and cookie !\"\n\n    \n]\n\n\n),\n \ndefault\n=\n'*'\n))\n\n\n# ['*', 'likes', '*', 'and', '*', '!']\n\n\n\nlist(templateseq((\n\n    \ns\n.\nsplit()\n \nfor\n \ns\n \nin\n \n[\n\n        \n\"Alice likes tea and coffee !\"\n,\n\n        \n\"Bob likes sushi and ramen !\"\n,\n\n        \n\"Elisa or Anna likes icecream and cake and cookie !\"\n\n    \n]\n\n\n),\n \ndefault\n=\n'*'\n,\n \nsimple\n=\nFalse))\n\n\n# ['*', 'likes', '*', 'and', '*', '!']\n\n\n\n# For more complex data.\n\n\nlist(templateseq((\n\n    \ns\n.\nsplit()\n \nfor\n \ns\n \nin\n \n[\n\n        \n\"! Alice likes tea and coffee ! !\"\n,\n\n        \n\"Bob likes sushi and ramen ! !\"\n,\n\n        \n\"Elisa or Anna likes icecream and cake and cookie ! !\"\n\n    \n]\n\n\n),\n \ndefault\n=\n'*'\n))\n\n\n# Incorrect template.\n\n\n# ['*', 'likes', '*', 'and', '*']\n\n\n\nlist(templateseq((\n\n    \ns\n.\nsplit()\n \nfor\n \ns\n \nin\n \n[\n\n        \n\"! Alice likes tea and coffee ! !\"\n,\n\n        \n\"Bob likes sushi and ramen ! !\"\n,\n\n        \n\"Elisa or Anna likes icecream and cake and cookie ! !\"\n\n    \n]\n\n\n),\n \ndefault\n=\n'*'\n,\n \nsimple\n=\nFalse))\n\n\n# ['*', 'likes', '*', 'and', '*', '!', '!']\n\n\n\n\n\n\nSequence Comparison\n\u00b6\n\n\nTools for comparing sequences.\n\n\nproductcmp\n\u00b6\n\n\nproductcmp(x, y)\n compares two sequences \nx\n and \ny\n with equal length according to \nproduct order\n. Returns \n-1\n if smaller, \n0\n if equal, \n1\n if greater, and \nNone\n if not comparable.\n\n\n\n\nThrow exception if \nx\n and \ny\n have different lengths.\n\n\n\n\nproductcmp(\n\n    \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \n[\n4\n,\n \n5\n,\n \n6\n]\n\n\n)\n\n\n# 1\n\n\n\nproductcmp(\n\n    \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \n[\n4\n,\n \n3\n,\n \n2\n]\n\n\n)\n\n\n# None\n\n\n\n\n\n\nSequence Sorting\n\u00b6\n\n\nTools for sorting sequences.\n\n\nsortedbyrank\n\u00b6\n\n\nsortedbyrank(data, ranks, reverse=False)\n returns the sorted list of \ndata\n, according to the respective rank of each individual element in \nranks\n.\n\n\nsortedbyrank(\n\n    \n[\n'a'\n,\n \n'b'\n,\n \n'c'\n],\n\n    \n[\n  \n3\n,\n   \n2\n,\n   \n1\n]\n\n\n)\n\n\n# ['c', 'b', 'a']\n\n\n\n\n\n\nSequence Encoding/Decoding\n\u00b6\n\n\nTools for encoding/decoding sequences.\n\n\ncompress\n\u00b6\n\n\ncompress(data, key=None)\n compresses the sequence by encoding continuous identical \nItem\n to \n(Item, Count)\n, according to \nrun-length encoding\n.\n\n\n\n\nWarning\n\n\nDifferent from \nitertools.compress\n.\n\n\n\n\nlist(compress([\n1\n,\n \n2\n,\n \n2\n,\n \n3\n,\n \n3\n,\n \n3\n,\n \n4\n,\n \n4\n,\n \n4\n,\n \n4\n]))\n\n\n# [(1, 1), (2, 2), (3, 3), (4, 4)]\n\n\n\n\n\n\ndecompress\n\u00b6\n\n\ndecompress(data)\n decompresses the sequence by decoding \n(Item, Count)\n to continuous identical \nItem\n, according to \nrun-length encoding\n.\n\n\nlist(decompress([(\n1\n,\n \n1\n),\n \n(\n2\n,\n \n2\n),\n \n(\n3\n,\n \n3\n),\n \n(\n4\n,\n \n4\n)]))\n\n\n# [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\n\n\n\n\ntodeltas\n\u00b6\n\n\ntodeltas(data, op=operator.sub)\n compresses the sequence by encoding the difference between previous and current items, according to \ndelta encoding\n.\n\n\n\n\nFor custom type of item, either define the \n-\n operator or specify the \nop\n function computing the difference.\n\n\n\n\nlist(todeltas([\n1\n,\n \n2\n,\n \n2\n,\n \n3\n,\n \n3\n,\n \n3\n,\n \n4\n,\n \n4\n,\n \n4\n,\n \n4\n]))\n\n\n# [1, 1, 0, 1, 0, 0, 1, 0, 0, 0]\n\n\n\n\n\n\nfromdeltas\n\u00b6\n\n\nfromdeltas(data, op=operator.add)\n decompresses the sequence by decoding the difference between previous and current items, according to \ndelta encoding\n.\n\n\n\n\nFor custom type of item, either define the \n+\n operator or specify the \nop\n function merging the difference.\n\n\n\n\nlist(fromdeltas([\n1\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n0\n,\n \n0\n]))\n\n\n# [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]\n\n\n\n\n\n\nSequence Transformation\n\u00b6\n\n\nTools for transforming sequences.\n\n\niter2seq\n\u00b6\n\n\niter2seq(iterable, target=tuple)\n converts any iterable sequence \niterable\n to an indexable and sizable sequence with type \ntarget=tuple\n if necessary, defaults to tuple.\n\n\n\n\nWarning\n\n\nThis function reads the sequence at once.\n\n\n\n\n\n\nTip\n\n\nUseful if you need to scan the sequence more than once.\n\n\n\n\nSequence Modeling\n\u00b6\n\n\nTools for modeling sequences.\n\n\nseq2grams\n\u00b6\n\n\nseq2grams(seq, n, pad=no_default)\n returns the ordered \nn\n-grams\n of sequence \nseq\n.\n\n\n\n\nOptional padding at the start and end can be added by specifying \npad\n.\n\n\n\n\nlist(seq2grams(range(\n5\n),\n \n3\n))\n\n\n# [(0, 1, 2),\n\n\n#  (1, 2, 3),\n\n\n#  (2, 3, 4)]\n\n\n\nlist(seq2grams(range(\n5\n),\n \n3\n,\n \npad\n=\nNone))\n\n\n# [(None, None, 0),\n\n\n#  (None, 0, 1),\n\n\n#  (0, 1, 2),\n\n\n#  (1, 2, 3),\n\n\n#  (2, 3, 4),\n\n\n#  (3, 4, None),\n\n\n#  (4, None, None)]\n\n\n\n\n\n\ngramstats\n\u00b6\n\n\ngramstats(seqs, numgrams=2)\n computes the frequency of each \nn\n-grams in sequences \nseqs\n.\n\n\n\n\nwhere \nn\n is specified by \nnumgrams\n.\n\n\n\n\ngramstats([\n\n    \n\"python\"\n,\n\n    \n\"python2\"\n,\n\n    \n\"python2.7\"\n,\n\n    \n\"python3\"\n,\n\n    \n\"python3.7\"\n\n\n])\n\n\n# {('p', 'y'): 5,\n\n\n#  ('y', 't'): 5,\n\n\n#  ('t', 'h'): 5,\n\n\n#  ('h', 'o'): 5,\n\n\n#  ('o', 'n'): 5,\n\n\n#  ('n', '2'): 2,\n\n\n#  ('2', '.'): 1,\n\n\n#  ('.', '7'): 2,\n\n\n#  ('n', '3'): 2,\n\n\n#  ('3', '.'): 1}\n\n\n\n\n\n\nprobability\n\u00b6\n\n\nprobability(seq, grams, numgrams=2)\n computes the probability of generating sequence \nseq\n by the \nn\n-grams and their respective frequencies in \ngrams\n.\n\n\n\n\nwhere \nn\n is specified by \nnumgrams\n.\n\n\n\n\n\n\nTip\n\n\nThere are many publicily available pre-trained \nn\n-grams models on text.\n\n\n\n\ngs\n \n=\n \ngramstats([\n\n    \n\"python\"\n,\n\n    \n\"python2\"\n,\n\n    \n\"python2.7\"\n,\n\n    \n\"python3\"\n,\n\n    \n\"python3.7\"\n\n\n])\n\n\n\nprobability(\n\"pypy\"\n,\n \ngs)\n\n\n# 0.10005840148165537\n\n\n\nprobability(\n\"pypy3\"\n,\n \ngs)\n\n\n# 0.07422696190252057",
            "title": "Overview"
        },
        {
            "location": "/functions/seqtools/#sequence-matching",
            "text": "",
            "title": "Sequence Matching"
        },
        {
            "location": "/functions/seqtools/#matchingfrequencies",
            "text": "matchingfrequencies(*seqs, key=None)  returns each item and the respective number of sequences in  seqs  contains it.   Optional key function  key  can be specified.    Tip  If each sequence is sorted, then optimized  sortedtools.matchingfrequencies  with the same API should be used for better efficiency.  For the frequency of each item within a single sequence, use  toolz.itertoolz.frequencies .   list(matchingfrequencies( \n     [ 0 ,   1 ,   2 ,   3 ,   4 ], \n     [ 1 ,   1 ,   1 ,   3 ,   4 ], \n     [ 2 ,   1 ,   2 ,   2 ,   0 ], \n     [ 1 ,   1 ,   1 ,   2 ,   2 ]  ))  # [(0, 2), (1, 4), (2, 3), (3, 2), (4, 2)]",
            "title": "matchingfrequencies"
        },
        {
            "location": "/functions/seqtools/#sequence-alignment-and-join",
            "text": "Tools for aligning and joining sequences.",
            "title": "Sequence Alignment and Join"
        },
        {
            "location": "/functions/seqtools/#match",
            "text": "match(a, b, default=None)  matches two sequences  a  and  b  in pairs, such that the total number of matching pairs is maximized.   If there are multiple alignments having the same number, the leftmost one is returned.    Warning  This function reads all sequences at once.    Tip  If both two sequences are sorted, respectively, then optimized  sortedtools.sortedmatch  with the same API should be used for better efficiency.   list(match( \n     [ 0 ,      1 ,   1 ,   0 ,   1 ], \n     [ 0 ,   0 ,   1 ,   1 ,      1 ]  ))  # [(0, 0),  #  (None, 0),  #  (1, 1),  #  (1, 1),  #  (0, None),  #  (1, 1)]",
            "title": "match"
        },
        {
            "location": "/functions/seqtools/#align",
            "text": "align(a, b, cost=None, bound=inf, default=None)  computes the  alignment  two sequences  a  and  b , such that the total cost of the aligned sequences given the pair-wise cost function  cost(x, y)  is minimized.    Assume the sequences after alignment are  a'  and  b' . The total cost is  sum(cost(x, y) for x, y in zip(a', b')) .    Both the minimum total cost and the respective aligned sequences are returned as a tuple.    In default, the cost function  cost(x, y)  returns  0  when  x == y  and  1  when not. This is equal to the  edit distance .    To speedup the computation, a threshold of maximum cost  bound=inf  can be specified. When there is no satisfying result,  None  is returned.    If there are multiple alignments having the same cost, the leftmost one is returned.     Warning  This function reads all sequences at once.   align( \n     [ 0 ,      1 ,   1 ,   0 ,   1 ], \n     [ 0 ,   0 ,   1 ,   1 ,      1 ]  )  # (2, ([0, None, 1, 1,    0, 1],  #      [0,    0, 1, 1, None, 1]))  align( \n     [ 0 ,      1 ,   1 ,   0 ,   1 ], \n     [ 0 ,   0 ,   1 ,   1 ,      1 ], \n     bound = 1  )  # None",
            "title": "align"
        },
        {
            "location": "/functions/seqtools/#join",
            "text": "join(leftseq, rightseq, leftkey=None, rightkey=None, leftdefault=no_default, rightdefault=no_default)  joins two sequences, optionally according to  leftkey  and  rightkey , respectively. Outer join is also supported.   Warning  This function reads the first sequence at once.    Tip  If both two sequences are sorted according to  leftkey  and  rightkey , respectively, then optimized  sortedtools.sortedjoin  with the same API should be used for better efficiency.    Info  join  is just a wrapper of  toolz.itertools.join  with the same more friendly API of  sortedtools.sortedjoin .   list(join( \n     [     - 1 ,   - 1 ,   - 2 ,      - 4 ,   - 5 ,      - 6 ], \n     [ 0 ,    1 ,    1 ,    2 ,   3 ,    4 ,    5 ,   5 ], \n     leftkey = abs,   leftdefault = None  ))  # [(None, 0),  #  (-1, 1),  #  (-1, 1),  #  (-1, 1),  #  (-1, 1),  #  (-2, 2),  #  (None, 3),  #  (-4, 4),  #  (-5, 5),  #  (-5, 5)]",
            "title": "join"
        },
        {
            "location": "/functions/seqtools/#templateseq",
            "text": "templateseq(seqs, default=None, simple=True)  finds the common template of all the sequences  seqs .  default=None  is used to denote any placeholder sub-sequence.    For better performance, option  simple  is enabled in default for only one scan of the sequences. However, it may work incorrectly for more complex template, which is:    Any part of the template appears more than once in the same sequence,    Any part of the template does not always appear before or after than another according to the same order part among sequences.       Warning  This function reads all the sequences at once.  This function reads all the sequences more than once when  simple = False .    Tip  Essentially, each template is a closed sequential pattern covering all the sequences. Please check  PrefixSpan-Py  for more advanced scenarios.   list(templateseq(( \n     s . split()   for   s   in   [ \n         \"Alice likes tea and coffee !\" , \n         \"Bob likes sushi and ramen !\" , \n         \"Elisa or Anna likes icecream and cake and cookie !\" \n     ]  ),   default = '*' ))  # ['*', 'likes', '*', 'and', '*', '!']  list(templateseq(( \n     s . split()   for   s   in   [ \n         \"Alice likes tea and coffee !\" , \n         \"Bob likes sushi and ramen !\" , \n         \"Elisa or Anna likes icecream and cake and cookie !\" \n     ]  ),   default = '*' ,   simple = False))  # ['*', 'likes', '*', 'and', '*', '!']  # For more complex data.  list(templateseq(( \n     s . split()   for   s   in   [ \n         \"! Alice likes tea and coffee ! !\" , \n         \"Bob likes sushi and ramen ! !\" , \n         \"Elisa or Anna likes icecream and cake and cookie ! !\" \n     ]  ),   default = '*' ))  # Incorrect template.  # ['*', 'likes', '*', 'and', '*']  list(templateseq(( \n     s . split()   for   s   in   [ \n         \"! Alice likes tea and coffee ! !\" , \n         \"Bob likes sushi and ramen ! !\" , \n         \"Elisa or Anna likes icecream and cake and cookie ! !\" \n     ]  ),   default = '*' ,   simple = False))  # ['*', 'likes', '*', 'and', '*', '!', '!']",
            "title": "templateseq"
        },
        {
            "location": "/functions/seqtools/#sequence-comparison",
            "text": "Tools for comparing sequences.",
            "title": "Sequence Comparison"
        },
        {
            "location": "/functions/seqtools/#productcmp",
            "text": "productcmp(x, y)  compares two sequences  x  and  y  with equal length according to  product order . Returns  -1  if smaller,  0  if equal,  1  if greater, and  None  if not comparable.   Throw exception if  x  and  y  have different lengths.   productcmp( \n     [ 1 ,   2 ,   3 ], \n     [ 4 ,   5 ,   6 ]  )  # 1  productcmp( \n     [ 1 ,   2 ,   3 ], \n     [ 4 ,   3 ,   2 ]  )  # None",
            "title": "productcmp"
        },
        {
            "location": "/functions/seqtools/#sequence-sorting",
            "text": "Tools for sorting sequences.",
            "title": "Sequence Sorting"
        },
        {
            "location": "/functions/seqtools/#sortedbyrank",
            "text": "sortedbyrank(data, ranks, reverse=False)  returns the sorted list of  data , according to the respective rank of each individual element in  ranks .  sortedbyrank( \n     [ 'a' ,   'b' ,   'c' ], \n     [    3 ,     2 ,     1 ]  )  # ['c', 'b', 'a']",
            "title": "sortedbyrank"
        },
        {
            "location": "/functions/seqtools/#sequence-encodingdecoding",
            "text": "Tools for encoding/decoding sequences.",
            "title": "Sequence Encoding/Decoding"
        },
        {
            "location": "/functions/seqtools/#compress",
            "text": "compress(data, key=None)  compresses the sequence by encoding continuous identical  Item  to  (Item, Count) , according to  run-length encoding .   Warning  Different from  itertools.compress .   list(compress([ 1 ,   2 ,   2 ,   3 ,   3 ,   3 ,   4 ,   4 ,   4 ,   4 ]))  # [(1, 1), (2, 2), (3, 3), (4, 4)]",
            "title": "compress"
        },
        {
            "location": "/functions/seqtools/#decompress",
            "text": "decompress(data)  decompresses the sequence by decoding  (Item, Count)  to continuous identical  Item , according to  run-length encoding .  list(decompress([( 1 ,   1 ),   ( 2 ,   2 ),   ( 3 ,   3 ),   ( 4 ,   4 )]))  # [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]",
            "title": "decompress"
        },
        {
            "location": "/functions/seqtools/#todeltas",
            "text": "todeltas(data, op=operator.sub)  compresses the sequence by encoding the difference between previous and current items, according to  delta encoding .   For custom type of item, either define the  -  operator or specify the  op  function computing the difference.   list(todeltas([ 1 ,   2 ,   2 ,   3 ,   3 ,   3 ,   4 ,   4 ,   4 ,   4 ]))  # [1, 1, 0, 1, 0, 0, 1, 0, 0, 0]",
            "title": "todeltas"
        },
        {
            "location": "/functions/seqtools/#fromdeltas",
            "text": "fromdeltas(data, op=operator.add)  decompresses the sequence by decoding the difference between previous and current items, according to  delta encoding .   For custom type of item, either define the  +  operator or specify the  op  function merging the difference.   list(fromdeltas([ 1 ,   1 ,   0 ,   1 ,   0 ,   0 ,   1 ,   0 ,   0 ,   0 ]))  # [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]",
            "title": "fromdeltas"
        },
        {
            "location": "/functions/seqtools/#sequence-transformation",
            "text": "Tools for transforming sequences.",
            "title": "Sequence Transformation"
        },
        {
            "location": "/functions/seqtools/#iter2seq",
            "text": "iter2seq(iterable, target=tuple)  converts any iterable sequence  iterable  to an indexable and sizable sequence with type  target=tuple  if necessary, defaults to tuple.   Warning  This function reads the sequence at once.    Tip  Useful if you need to scan the sequence more than once.",
            "title": "iter2seq"
        },
        {
            "location": "/functions/seqtools/#sequence-modeling",
            "text": "Tools for modeling sequences.",
            "title": "Sequence Modeling"
        },
        {
            "location": "/functions/seqtools/#seq2grams",
            "text": "seq2grams(seq, n, pad=no_default)  returns the ordered  n -grams  of sequence  seq .   Optional padding at the start and end can be added by specifying  pad .   list(seq2grams(range( 5 ),   3 ))  # [(0, 1, 2),  #  (1, 2, 3),  #  (2, 3, 4)]  list(seq2grams(range( 5 ),   3 ,   pad = None))  # [(None, None, 0),  #  (None, 0, 1),  #  (0, 1, 2),  #  (1, 2, 3),  #  (2, 3, 4),  #  (3, 4, None),  #  (4, None, None)]",
            "title": "seq2grams"
        },
        {
            "location": "/functions/seqtools/#gramstats",
            "text": "gramstats(seqs, numgrams=2)  computes the frequency of each  n -grams in sequences  seqs .   where  n  is specified by  numgrams .   gramstats([ \n     \"python\" , \n     \"python2\" , \n     \"python2.7\" , \n     \"python3\" , \n     \"python3.7\"  ])  # {('p', 'y'): 5,  #  ('y', 't'): 5,  #  ('t', 'h'): 5,  #  ('h', 'o'): 5,  #  ('o', 'n'): 5,  #  ('n', '2'): 2,  #  ('2', '.'): 1,  #  ('.', '7'): 2,  #  ('n', '3'): 2,  #  ('3', '.'): 1}",
            "title": "gramstats"
        },
        {
            "location": "/functions/seqtools/#probability",
            "text": "probability(seq, grams, numgrams=2)  computes the probability of generating sequence  seq  by the  n -grams and their respective frequencies in  grams .   where  n  is specified by  numgrams .    Tip  There are many publicily available pre-trained  n -grams models on text.   gs   =   gramstats([ \n     \"python\" , \n     \"python2\" , \n     \"python2.7\" , \n     \"python3\" , \n     \"python3.7\"  ])  probability( \"pypy\" ,   gs)  # 0.10005840148165537  probability( \"pypy3\" ,   gs)  # 0.07422696190252057",
            "title": "probability"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/",
            "text": "Sequence Matching without Gap\n\u00b6\n\n\nTools for matching sequences (including strings), without gaps allowed between matching items.\n\n\nbestsubseq\n\u00b6\n\n\nbestsubseq(a, key)\n finds the best sub-sequence of \na\n that maximizes the key function \nkey\n.\n\n\n\n\nWarning\n\n\nThis function reads the sequence at once.\n\n\n\n\nbestsubseq([\n1\n,\n \n-\n2\n,\n \n3\n,\n \n-\n4\n,\n \n5\n,\n \n-\n6\n],\n \nsum)\n\n\n# [5]\n\n\n\n\n\n\nfindallsubseqs\n\u00b6\n\n\nfindallsubseqs(a, b, overlap=False)\n returns all the positions where \na\n is a sub-sequence of \nb\n.\n\n\n\n\n\n\nIn default, no overlapping is allowed. You can change this behavior by specify \noverlap\n.\n\n\n\n\n\n\nUnlike other function in \nseqtools\n, empty list is returned when \na\n is empty.\n\n\n\n\n\n\n\n\nWarning\n\n\nThis function reads the first sequence at once.\n\n\n\n\nlist(findallsubseqs(\n\n    \n[\n   \n0\n,\n \n1\n,\n \n0\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n]\n\n\n))\n\n\n# [1]\n\n\n\nlist(findallsubseqs(\n\n    \n[\n   \n0\n,\n \n1\n,\n \n0\n],\n\n  \n# [         0, 1, 0],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n],\n\n    \noverlap\n=\nTrue\n\n\n))\n\n\n# [1, 3]\n\n\n\n\n\n\nfindsubseq\n\u00b6\n\n\nfindsubseq(a, b)\n returns the first position where \na\n is a sub-sequence of \nb\n, or \n-1\n when not found.\n\n\n\n\nWarning\n\n\nThis function reads the first sequence at once.\n\n\n\n\nfindsubseq(\n\n    \n[\n   \n0\n,\n \n1\n,\n \n0\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n]\n\n\n)\n\n\n# 1\n\n\n\n\n\n\nissubseq\n\u00b6\n\n\nissubseq(a, b)\n checks if \na\n is a sub-sequence of \nb\n.\n\n\n\n\nWarning\n\n\nThis function reads the first sequence at once.\n\n\n\n\nissubseq(\n\n    \n[\n   \n0\n,\n \n1\n,\n \n0\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n]\n\n\n)\n\n\n# True\n\n\n\n\n\n\ncommonsubseq\n\u00b6\n\n\ncommonsubseq(a, b)\n finds the \nlongest common sub-sequence\n among two sequences \na\n and \nb\n.\n\n\n\n\nWarning\n\n\nThis function reads all sequences at once.\n\n\n\n\nlist(commonsubseq(\n\n    \n[\n   \n0\n,\n \n1\n,\n \n1\n,\n   \n0\n,\n \n1\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n1\n,\n \n1\n]\n\n\n))\n\n\n# [0, 1, 1]\n\n\n\n\n\n\nSub-Sequence Enumeration without Gap\n\u00b6\n\n\nTools for enumerating sub-sequences without gap.\n\n\nenumeratesubseqs\n\u00b6\n\n\nenumeratesubseqs(seq)\n enumerates all of \nseq\n\u2018s non-empty sub-sequences in \nlexicographical order\n.\n\n\n\n\nAlthough \nseq\n is a sub-sequence of itself, it is not returned.\n\n\n\n\n\n\nWarning\n\n\nThis function reads the sequence at once.\n\n\n\n\nlist(enumeratesubseqs([\n0\n,\n \n1\n,\n \n0\n,\n \n2\n]))\n\n\n# [[0],\n\n\n#  [0, 1],\n\n\n#  [0, 1, 0],\n\n\n#  [1],\n\n\n#  [1, 0],\n\n\n#  [1, 0, 2],\n\n\n#  [0],\n\n\n#  [0, 2],\n\n\n#  [2]]\n\n\n\n\n\n\nnonsharingsubseqs\n\u00b6\n\n\nnonsharingsubseqs(*seqs, closed=True)\n finds all the non-sharing non-empty sub-sequences among \nseqs\n, such that the item of each sub-sequence only appears in any sequence of \nseqs\n containing that respective sub-sequence.\n\n\n\n\n\n\nEach sub-sequence is a tuple of items.\n\n\n\n\n\n\nclosed=True\n can be specified to return only the longest sub-sequences, i.e. no sub-sequence of is a sub-sequence of another sub-sequence.\n\n\n\n\n\n\n\n\nWarning\n\n\nThis function reads all sequences at once.\n\n\n\n\ndb\n \n=\n \n[\n\n    \n[\n0\n,\n \n1\n,\n \n2\n,\n \n3\n,\n \n4\n],\n\n    \n[\n1\n,\n \n1\n,\n \n1\n,\n \n3\n,\n \n4\n],\n\n    \n[\n2\n,\n \n1\n,\n \n2\n,\n \n2\n,\n \n0\n],\n\n    \n[\n1\n,\n \n1\n,\n \n1\n,\n \n2\n,\n \n2\n],\n\n\n]\n\n\n\nnonsharingsubseqs(db)\n\n\n# {(0,): 2,\n\n\n#  (1,): 4,\n\n\n#  (2,): 3,\n\n\n#  (3, 4): 2}\n\n\n\nnonsharingsubseqs(db,\n \nclosed\n=\nFalse)\n\n\n# {(0,): 2,\n\n\n#  (1,): 4,\n\n\n#  (2,): 3,\n\n\n#  (3,): 2,\n\n\n#  (3, 4): 2,\n\n\n#  (4,): 2}\n\n\n\n\n\n\nSequence Partition\n\u00b6\n\n\nTools for sequence partition.\n\n\npartitionbysubseqs\n\u00b6\n\n\npartitionbysubseqs(subseqs, seq)\n finds the partitions of sequence \nseq\n, according to a known sets of sub-sequences \nsubseqs\n.\n\n\n\n\nFor unknown sub-sequences, the longest ones are outputted.\n\n\n\n\n\n\nWarning\n\n\nThis function reads the sequence \nseq\n at once.\n\n\n\n\nlist(partitionbysubseqs(\n\n    \n[\n\n        \n(\n0\n,),\n\n        \n(\n1\n,),\n\n        \n(\n2\n,),\n\n        \n(\n3\n,\n \n4\n)\n\n    \n],\n\n    \n[\n-\n1\n,\n \n0\n,\n \n1\n,\n \n1\n,\n \n5\n,\n \n6\n,\n \n3\n,\n \n4\n,\n \n7\n]\n\n\n))\n\n\n# [[-1], [0], [1], [1], [5, 6], [3, 4], [7]]",
            "title": "Sub-Sequence without Gap"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#sequence-matching-without-gap",
            "text": "Tools for matching sequences (including strings), without gaps allowed between matching items.",
            "title": "Sequence Matching without Gap"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#bestsubseq",
            "text": "bestsubseq(a, key)  finds the best sub-sequence of  a  that maximizes the key function  key .   Warning  This function reads the sequence at once.   bestsubseq([ 1 ,   - 2 ,   3 ,   - 4 ,   5 ,   - 6 ],   sum)  # [5]",
            "title": "bestsubseq"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#findallsubseqs",
            "text": "findallsubseqs(a, b, overlap=False)  returns all the positions where  a  is a sub-sequence of  b .    In default, no overlapping is allowed. You can change this behavior by specify  overlap .    Unlike other function in  seqtools , empty list is returned when  a  is empty.     Warning  This function reads the first sequence at once.   list(findallsubseqs( \n     [     0 ,   1 ,   0 ], \n     [ 0 ,   0 ,   1 ,   0 ,   1 ,   0 ]  ))  # [1]  list(findallsubseqs( \n     [     0 ,   1 ,   0 ], \n   # [         0, 1, 0], \n     [ 0 ,   0 ,   1 ,   0 ,   1 ,   0 ], \n     overlap = True  ))  # [1, 3]",
            "title": "findallsubseqs"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#findsubseq",
            "text": "findsubseq(a, b)  returns the first position where  a  is a sub-sequence of  b , or  -1  when not found.   Warning  This function reads the first sequence at once.   findsubseq( \n     [     0 ,   1 ,   0 ], \n     [ 0 ,   0 ,   1 ,   0 ,   1 ,   0 ]  )  # 1",
            "title": "findsubseq"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#issubseq",
            "text": "issubseq(a, b)  checks if  a  is a sub-sequence of  b .   Warning  This function reads the first sequence at once.   issubseq( \n     [     0 ,   1 ,   0 ], \n     [ 0 ,   0 ,   1 ,   0 ,   1 ,   0 ]  )  # True",
            "title": "issubseq"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#commonsubseq",
            "text": "commonsubseq(a, b)  finds the  longest common sub-sequence  among two sequences  a  and  b .   Warning  This function reads all sequences at once.   list(commonsubseq( \n     [     0 ,   1 ,   1 ,     0 ,   1 ], \n     [ 0 ,   0 ,   1 ,   1 ,   1 ]  ))  # [0, 1, 1]",
            "title": "commonsubseq"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#sub-sequence-enumeration-without-gap",
            "text": "Tools for enumerating sub-sequences without gap.",
            "title": "Sub-Sequence Enumeration without Gap"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#enumeratesubseqs",
            "text": "enumeratesubseqs(seq)  enumerates all of  seq \u2018s non-empty sub-sequences in  lexicographical order .   Although  seq  is a sub-sequence of itself, it is not returned.    Warning  This function reads the sequence at once.   list(enumeratesubseqs([ 0 ,   1 ,   0 ,   2 ]))  # [[0],  #  [0, 1],  #  [0, 1, 0],  #  [1],  #  [1, 0],  #  [1, 0, 2],  #  [0],  #  [0, 2],  #  [2]]",
            "title": "enumeratesubseqs"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#nonsharingsubseqs",
            "text": "nonsharingsubseqs(*seqs, closed=True)  finds all the non-sharing non-empty sub-sequences among  seqs , such that the item of each sub-sequence only appears in any sequence of  seqs  containing that respective sub-sequence.    Each sub-sequence is a tuple of items.    closed=True  can be specified to return only the longest sub-sequences, i.e. no sub-sequence of is a sub-sequence of another sub-sequence.     Warning  This function reads all sequences at once.   db   =   [ \n     [ 0 ,   1 ,   2 ,   3 ,   4 ], \n     [ 1 ,   1 ,   1 ,   3 ,   4 ], \n     [ 2 ,   1 ,   2 ,   2 ,   0 ], \n     [ 1 ,   1 ,   1 ,   2 ,   2 ],  ]  nonsharingsubseqs(db)  # {(0,): 2,  #  (1,): 4,  #  (2,): 3,  #  (3, 4): 2}  nonsharingsubseqs(db,   closed = False)  # {(0,): 2,  #  (1,): 4,  #  (2,): 3,  #  (3,): 2,  #  (3, 4): 2,  #  (4,): 2}",
            "title": "nonsharingsubseqs"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#sequence-partition",
            "text": "Tools for sequence partition.",
            "title": "Sequence Partition"
        },
        {
            "location": "/functions/seqtools/seqwithoutgap/#partitionbysubseqs",
            "text": "partitionbysubseqs(subseqs, seq)  finds the partitions of sequence  seq , according to a known sets of sub-sequences  subseqs .   For unknown sub-sequences, the longest ones are outputted.    Warning  This function reads the sequence  seq  at once.   list(partitionbysubseqs( \n     [ \n         ( 0 ,), \n         ( 1 ,), \n         ( 2 ,), \n         ( 3 ,   4 ) \n     ], \n     [ - 1 ,   0 ,   1 ,   1 ,   5 ,   6 ,   3 ,   4 ,   7 ]  ))  # [[-1], [0], [1], [1], [5, 6], [3, 4], [7]]",
            "title": "partitionbysubseqs"
        },
        {
            "location": "/functions/seqtools/seqwithgap/",
            "text": "Sequence Matching with Gap\n\u00b6\n\n\nTools for matching sequences (including strings), with gaps allowed between matching items.\n\n\nbestsubseqwithgap\n\u00b6\n\n\nbestsubseqwithgap(a, key)\n finds the best sub-sequence of \na\n that maximizes the key function \nkey\n, where gaps are allowed.\n\n\n\n\nWarning\n\n\nThis function reads the sequence at once.\n\n\n\n\nbestsubseqwithgap([\n1\n,\n \n-\n2\n,\n \n3\n,\n \n-\n4\n,\n \n5\n,\n \n-\n6\n],\n \nsum)\n\n\n# [1, 3, 5]\n\n\n\n\n\n\nfindallsubseqswithgap\n\u00b6\n\n\nfindallsubseqswithgap(a, b, overlap=False)\n returns all the positions where \na\n is a sub-sequence of \nb\n.\n\n\n\n\n\n\nIn default, no overlapping is allowed. You can change this behavior by specify \noverlap\n.\n\n\n\n\n\n\nUnlike other function in \nseqtools\n, empty list is returned when \na\n is empty.\n\n\n\n\n\n\n\n\nWarning\n\n\nThis function reads all sequences at once.\n\n\n\n\nlist(findallsubseqswithgap(\n\n    \n[\n0\n,\n    \n1\n,\n    \n1\n],\n\n  \n# [   0,             1, 1],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n1\n]\n\n\n))\n\n\n# [[0, 2, 4], [1, 6, 7]]\n\n\n\n# Enumerates all the possible matchings.\n\n\nlist(findallsubseqswithgap(\n\n   \n[\n0\n,\n    \n1\n,\n    \n1\n],\n\n \n# [0,    1,          1],\n\n \n# ...\n\n \n# [               0, 1, 1],\n\n   \n[\n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n1\n],\n\n   \noverlap\n=\nTrue\n\n\n))\n\n\n# [[0, 2, 4],\n\n\n#  [0, 2, 6],\n\n\n#  [0, 2, 7],\n\n\n#  [0, 4, 6],\n\n\n#  [0, 4, 7],\n\n\n#  [0, 6, 7],\n\n\n#  [1, 2, 4],\n\n\n#  [1, 2, 6],\n\n\n#  [1, 2, 7],\n\n\n#  [1, 4, 6],\n\n\n#  [1, 4, 7],\n\n\n#  [1, 6, 7],\n\n\n#  [3, 4, 6],\n\n\n#  [3, 4, 7],\n\n\n#  [3, 6, 7],\n\n\n#  [5, 6, 7]]\n\n\n\n\n\n\nfindsubseqwithgap\n\u00b6\n\n\nfindsubseqwithgap(a, b)\n returns the matching positions where \na\n is a sub-sequence of \nb\n, where gaps are allowed, or \nNone\n when not found.\n\n\nlist(findsubseqwithgap(\n\n    \n[\n0\n,\n    \n1\n,\n    \n1\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n]\n\n\n))\n\n\n# [0, 2, 4]\n\n\n\n\n\n\nissubseqwithgap\n\u00b6\n\n\nissubseqwithgap(a, b)\n checks if \na\n is a sub-sequence of \nb\n, where gaps are allowed.\n\n\nlist(issubseqwithgap(\n\n    \n[\n0\n,\n    \n1\n,\n    \n1\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n0\n,\n \n1\n,\n \n0\n]\n\n\n))\n\n\n# True\n\n\n\n\n\n\ncommonsubseqwithgap\n\u00b6\n\n\ncommonsubseqwithgap(a, b)\n finds the \nlongest common sub-sequence\n among two sequences \na\n and \nb\n, where gaps are allowed.\n\n\n\n\nWarning\n\n\nThis function reads all sequences at once.\n\n\n\n\nlist(commonsubseqwithgap(\n\n    \n[\n0\n,\n    \n1\n,\n \n1\n,\n \n0\n,\n \n1\n],\n\n    \n[\n0\n,\n \n0\n,\n \n1\n,\n \n1\n,\n    \n1\n]\n\n\n))\n\n\n# [0, 1, 1, 1]\n\n\n\n\n\n\nSub-Sequence Enumeration with Gap\n\u00b6\n\n\nTools for enumerating sub-sequences with gap.\n\n\nenumeratesubseqswithgap\n\u00b6\n\n\nenumeratesubseqswithgap(seq)\n enumerates all of \nseq\n\u2018s non-empty sub-sequences in \nlexicographical order\n.\n\n\n\n\nAlthough \nseq\n is a sub-sequence of itself, it is not returned.\n\n\n\n\n\n\nWarning\n\n\nThis function reads the sequence at once.\n\n\n\n\nlist(enumeratesubseqswithgap([\n0\n,\n \n1\n,\n \n0\n,\n \n2\n]))\n\n\n# [(0,),\n\n\n#  (1,),\n\n\n#  (0,),\n\n\n#  (2,),\n\n\n#  (0, 1),\n\n\n#  (0, 0),\n\n\n#  (0, 2),\n\n\n#  (1, 0),\n\n\n#  (1, 2),\n\n\n#  (0, 2),\n\n\n#  (0, 1, 0),\n\n\n#  (0, 1, 2),\n\n\n#  (0, 0, 2),\n\n\n#  (1, 0, 2)]",
            "title": "Sub-Sequence with Gap"
        },
        {
            "location": "/functions/seqtools/seqwithgap/#sequence-matching-with-gap",
            "text": "Tools for matching sequences (including strings), with gaps allowed between matching items.",
            "title": "Sequence Matching with Gap"
        },
        {
            "location": "/functions/seqtools/seqwithgap/#bestsubseqwithgap",
            "text": "bestsubseqwithgap(a, key)  finds the best sub-sequence of  a  that maximizes the key function  key , where gaps are allowed.   Warning  This function reads the sequence at once.   bestsubseqwithgap([ 1 ,   - 2 ,   3 ,   - 4 ,   5 ,   - 6 ],   sum)  # [1, 3, 5]",
            "title": "bestsubseqwithgap"
        },
        {
            "location": "/functions/seqtools/seqwithgap/#findallsubseqswithgap",
            "text": "findallsubseqswithgap(a, b, overlap=False)  returns all the positions where  a  is a sub-sequence of  b .    In default, no overlapping is allowed. You can change this behavior by specify  overlap .    Unlike other function in  seqtools , empty list is returned when  a  is empty.     Warning  This function reads all sequences at once.   list(findallsubseqswithgap( \n     [ 0 ,      1 ,      1 ], \n   # [   0,             1, 1], \n     [ 0 ,   0 ,   1 ,   0 ,   1 ,   0 ,   1 ,   1 ]  ))  # [[0, 2, 4], [1, 6, 7]]  # Enumerates all the possible matchings.  list(findallsubseqswithgap( \n    [ 0 ,      1 ,      1 ], \n  # [0,    1,          1], \n  # ... \n  # [               0, 1, 1], \n    [ 0 ,   0 ,   1 ,   0 ,   1 ,   0 ,   1 ,   1 ], \n    overlap = True  ))  # [[0, 2, 4],  #  [0, 2, 6],  #  [0, 2, 7],  #  [0, 4, 6],  #  [0, 4, 7],  #  [0, 6, 7],  #  [1, 2, 4],  #  [1, 2, 6],  #  [1, 2, 7],  #  [1, 4, 6],  #  [1, 4, 7],  #  [1, 6, 7],  #  [3, 4, 6],  #  [3, 4, 7],  #  [3, 6, 7],  #  [5, 6, 7]]",
            "title": "findallsubseqswithgap"
        },
        {
            "location": "/functions/seqtools/seqwithgap/#findsubseqwithgap",
            "text": "findsubseqwithgap(a, b)  returns the matching positions where  a  is a sub-sequence of  b , where gaps are allowed, or  None  when not found.  list(findsubseqwithgap( \n     [ 0 ,      1 ,      1 ], \n     [ 0 ,   0 ,   1 ,   0 ,   1 ,   0 ]  ))  # [0, 2, 4]",
            "title": "findsubseqwithgap"
        },
        {
            "location": "/functions/seqtools/seqwithgap/#issubseqwithgap",
            "text": "issubseqwithgap(a, b)  checks if  a  is a sub-sequence of  b , where gaps are allowed.  list(issubseqwithgap( \n     [ 0 ,      1 ,      1 ], \n     [ 0 ,   0 ,   1 ,   0 ,   1 ,   0 ]  ))  # True",
            "title": "issubseqwithgap"
        },
        {
            "location": "/functions/seqtools/seqwithgap/#commonsubseqwithgap",
            "text": "commonsubseqwithgap(a, b)  finds the  longest common sub-sequence  among two sequences  a  and  b , where gaps are allowed.   Warning  This function reads all sequences at once.   list(commonsubseqwithgap( \n     [ 0 ,      1 ,   1 ,   0 ,   1 ], \n     [ 0 ,   0 ,   1 ,   1 ,      1 ]  ))  # [0, 1, 1, 1]",
            "title": "commonsubseqwithgap"
        },
        {
            "location": "/functions/seqtools/seqwithgap/#sub-sequence-enumeration-with-gap",
            "text": "Tools for enumerating sub-sequences with gap.",
            "title": "Sub-Sequence Enumeration with Gap"
        },
        {
            "location": "/functions/seqtools/seqwithgap/#enumeratesubseqswithgap",
            "text": "enumeratesubseqswithgap(seq)  enumerates all of  seq \u2018s non-empty sub-sequences in  lexicographical order .   Although  seq  is a sub-sequence of itself, it is not returned.    Warning  This function reads the sequence at once.   list(enumeratesubseqswithgap([ 0 ,   1 ,   0 ,   2 ]))  # [(0,),  #  (1,),  #  (0,),  #  (2,),  #  (0, 1),  #  (0, 0),  #  (0, 2),  #  (1, 0),  #  (1, 2),  #  (0, 2),  #  (0, 1, 0),  #  (0, 1, 2),  #  (0, 0, 2),  #  (1, 0, 2)]",
            "title": "enumeratesubseqswithgap"
        },
        {
            "location": "/functions/settools/",
            "text": "Source\n\n\nSet Matching\n\u00b6\n\n\nTools for matching sets.\n\n\nbestsubset\n\u00b6\n\n\nbestsubset(a, key)\n finds the best sub-set of \na\n that maximizes the key function \nkey\n.\n\n\nbestsubset({\n1\n,\n \n-\n2\n,\n \n3\n,\n \n-\n4\n,\n \n5\n,\n \n-\n6\n},\n \nsum)\n\n\n#          {1,     3,     5}\n\n\n\n\n\n\nsetcover\n\u00b6\n\n\nsetcover(whole, covered, key=len)\n solves the \nset cover problem\n by covering the universe set \nwhole\n as best as possible, using a subset of the covering sets \ncovered\n.\n\n\n\n\nIn default, the size of each set \nlen\n is used as key function \nkey\n to measure the coverage.\n\n\n\n\n\n\nWarning\n\n\nThis is an approximate algorithm, which means the returned result is not always the best.\n\n\n\n\nlist(setcover(\n\n    \n{\n \n1\n,\n \n2\n,\n \n3\n,\n         \n4\n,\n         \n5\n},\n\n    \n[{\n1\n,\n \n2\n,\n \n3\n},\n \n{\n2\n,\n \n3\n,\n \n4\n},\n \n{\n2\n,\n \n4\n,\n \n5\n}]\n\n\n))\n\n\n# [frozenset({1, 2, 3}), frozenset({2, 4, 5})]\n\n\n\n\n\n\nSet Operation\n\u00b6\n\n\nTools for set operations.\n\n\naddtoset\n\u00b6\n\n\naddtoset(s, x)\n checks whether adding \nx\n to set \ns\n is successful.\n\n\ns\n \n=\n \nset()\n\n\n\naddtoset(s,\n \n1\n)\n\n\n# True\n\n\n\naddtoset(s,\n \n1\n)\n\n\n# False\n\n\n\n\n\n\nSet Similarity\n\u00b6\n\n\nTools for set similarities.\n\n\njaccard\n\u00b6\n\n\njaccard(a, b)\n computes the \nJaccard similarity\n between two sets \na\n and \nb\n.\n\n\nmultisetjaccard\n\u00b6\n\n\nmultisetjaccard(a, b)\n computes the \nJaccard similarity\n between two multi-sets (Counters) \na\n and \nb\n.\n\n\nweightedjaccard\n\u00b6\n\n\nweightedjaccard(a, b, key=sum)\n computes the weighted \nJaccard similarity\n between two sets \na\n and \nb\n, using function \nkey\n to compute the total weight of the elements within a set.",
            "title": "settools"
        },
        {
            "location": "/functions/settools/#set-matching",
            "text": "Tools for matching sets.",
            "title": "Set Matching"
        },
        {
            "location": "/functions/settools/#bestsubset",
            "text": "bestsubset(a, key)  finds the best sub-set of  a  that maximizes the key function  key .  bestsubset({ 1 ,   - 2 ,   3 ,   - 4 ,   5 ,   - 6 },   sum)  #          {1,     3,     5}",
            "title": "bestsubset"
        },
        {
            "location": "/functions/settools/#setcover",
            "text": "setcover(whole, covered, key=len)  solves the  set cover problem  by covering the universe set  whole  as best as possible, using a subset of the covering sets  covered .   In default, the size of each set  len  is used as key function  key  to measure the coverage.    Warning  This is an approximate algorithm, which means the returned result is not always the best.   list(setcover( \n     {   1 ,   2 ,   3 ,           4 ,           5 }, \n     [{ 1 ,   2 ,   3 },   { 2 ,   3 ,   4 },   { 2 ,   4 ,   5 }]  ))  # [frozenset({1, 2, 3}), frozenset({2, 4, 5})]",
            "title": "setcover"
        },
        {
            "location": "/functions/settools/#set-operation",
            "text": "Tools for set operations.",
            "title": "Set Operation"
        },
        {
            "location": "/functions/settools/#addtoset",
            "text": "addtoset(s, x)  checks whether adding  x  to set  s  is successful.  s   =   set()  addtoset(s,   1 )  # True  addtoset(s,   1 )  # False",
            "title": "addtoset"
        },
        {
            "location": "/functions/settools/#set-similarity",
            "text": "Tools for set similarities.",
            "title": "Set Similarity"
        },
        {
            "location": "/functions/settools/#jaccard",
            "text": "jaccard(a, b)  computes the  Jaccard similarity  between two sets  a  and  b .",
            "title": "jaccard"
        },
        {
            "location": "/functions/settools/#multisetjaccard",
            "text": "multisetjaccard(a, b)  computes the  Jaccard similarity  between two multi-sets (Counters)  a  and  b .",
            "title": "multisetjaccard"
        },
        {
            "location": "/functions/settools/#weightedjaccard",
            "text": "weightedjaccard(a, b, key=sum)  computes the weighted  Jaccard similarity  between two sets  a  and  b , using function  key  to compute the total weight of the elements within a set.",
            "title": "weightedjaccard"
        },
        {
            "location": "/functions/sortedtools/",
            "text": "Source\n\n\n\n\nDanger\n\n\nFor most tools here except \nissorted\n, each sequence must already be sorted.\n\n\n\n\n\n\nInfo\n\n\nTools in \nseqtools\n can also be applied here. \nsortedtools\n only contains tools that either are unique to the concept of sorted sequence or have more efficient implementations.\n\n\n\n\nSequence Check\n\u00b6\n\n\nissorted\n\u00b6\n\n\nissorted(seq, key=None)\n returns if sequence \nseq\n is already sorted, optionally according to the key function \nkey\n.\n\n\nissorted([\n1\n,\n \n2\n,\n \n2\n,\n \n3\n])\n\n\n# True\n\n\n\n\n\n\nSequence Matching\n\u00b6\n\n\nTools for matching sorted sequences.\n\n\nsortedcommon\n\u00b6\n\n\nsortedcommon(a, b, key=None)\n returns the common elements between \na\n and \nb\n, optionally according to the key function \nkey\n.\n\n\n\n\nSuccess\n\n\nWhen both \na\n and \nb\n are sorted sets with no duplicate element, equal to \nsorted(set(a) & set(b))\n but more efficient.\n\n\n\n\nlist(sortedcommon(\n\n    \n[\n1\n,\n \n2\n,\n \n2\n,\n \n3\n],\n\n    \n[\n   \n2\n,\n    \n3\n,\n \n4\n,\n \n4\n]\n\n\n))\n\n\n# [2, 3]\n\n\n\n\n\n\nsortedalone\n\u00b6\n\n\nsortedalone(a, b, key=None)\n returns the elements not in both \na\n and \nb\n, optionally according to the key function \nkey\n.\n\n\n\n\nSuccess\n\n\nWhen both \na\n and \nb\n are sorted sets with no duplicate element, equal to \nsorted((set(a) | set(b)) - (set(a) & set(b)))\n but more efficient.\n\n\n\n\nlist(sortedalone(\n\n    \n[\n1\n,\n \n2\n,\n \n2\n,\n \n3\n],\n\n    \n[\n   \n2\n,\n    \n3\n,\n \n4\n,\n \n4\n]\n\n\n))\n\n\n# [1, 2, 4, 4]\n\n\n\n\n\n\nsorteddiff\n\u00b6\n\n\nsorteddiff(a, b, key=None)\n returns the elements only in \na\n and not in \nb\n, optionally according to the key function \nkey\n.\n\n\n\n\nSuccess\n\n\nWhen both \na\n and \nb\n are sorted sets with no duplicate element, equal to \nsorted(set(a) - set(b))\n but more efficient.\n\n\n\n\nlist(sorteddiff(\n\n    \n[\n1\n,\n \n2\n,\n \n2\n,\n \n3\n],\n\n    \n[\n   \n2\n,\n    \n3\n,\n \n4\n,\n \n4\n]\n\n\n))\n\n\n# [1, 2]\n\n\n\n\n\n\nissubsorted\n\u00b6\n\n\nissubsorted(a, b, key=None)\n checks if \na\n is a sorted sub-sequence of \nb\n, optionally according to the key function \nkey\n.\n\n\n\n\nWhen both \na\n and \nb\n are sorted sets with no duplicate element, equal to \nset(a) <= set(b)\n but more efficient.\n\n\n\n\nissubsorted(\n\n    \n[\n1\n,\n \n2\n,\n \n2\n,\n \n3\n],\n\n    \n[\n1\n,\n \n2\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n4\n]\n\n\n)\n\n\n# True\n\n\n\n\n\n\nmatchingfrequencies\n\u00b6\n\n\nmatchingfrequencies(*seqs, key=None)\n returns each item and the respective number of sequences in \nseqs\n contains it.\n\n\n\n\nOptional key function \nkey\n can be specified.\n\n\n\n\n\n\nSuccess\n\n\nThis implementation is space efficient. If there are \nn\n sequences, only \nO(n)\n space is used.\n\n\nsortedtools.matchingfrequencies\n is more efficient than \nseqtools.matchingfrequencies\n.\n\n\n\n\n\n\nTip\n\n\nFor the frequency of each item within a single sequence, use \ntoolz.itertoolz.frequencies\n.\n\n\n\n\nlist(matchingfrequencies(\n\n    \n[\n1\n,\n \n2\n,\n \n2\n,\n \n3\n],\n\n    \n[\n   \n2\n,\n    \n3\n,\n    \n4\n,\n \n5\n],\n\n    \n[\n1\n,\n       \n3\n,\n \n3\n,\n \n4\n]\n\n\n))\n\n\n# [(1, 2), (2, 2), (3, 3), (4, 2), (5, 1)]\n\n\n\n\n\n\nSequence Alignment and Join\n\u00b6\n\n\nTools for aligning and joining sorted sequences.\n\n\nsortedmatch\n\u00b6\n\n\nsortedmatch(a, b, default=None)\n matches two sorted sequences \na\n and \nb\n in pairs, such that the total number of matching pairs is maximized.\n\n\n\n\nIf there are multiple alignments having the same number, the leftmost one is returned.\n\n\n\n\n\n\nSuccess\n\n\nsortedmatch\n is more efficient than \nseqtools.match\n.\n\n\n\n\nlist(sortedmatch(\n\n    \n[\n1\n,\n \n2\n,\n \n2\n,\n \n3\n],\n\n    \n[\n   \n2\n,\n    \n3\n,\n \n4\n,\n \n4\n]\n\n\n))\n\n\n# [(1, None),\n\n\n#  (2, 2),\n\n\n#  (2, None),\n\n\n#  (3, 3),\n\n\n#  (None, 4),\n\n\n#  (None, 4)]\n\n\n\n\n\n\nsortedjoin\n\u00b6\n\n\nsortedjoin(leftseq, rightseq, leftkey=None, rightkey=None, leftdefault=no_default, rightdefault=no_default)\n joins two sequences, optionally according to \nleftkey\n and \nrightkey\n, respectively. Outer join is also supported.\n\n\n\n\nTwo sequences must be already sorted according to \nleftkey\n and \nrightkey\n, respectively.\n\n\n\n\n\n\nSuccess\n\n\nsortedjoin\n is more efficient than \nseqtools.join\n and its underneath \ntoolz.itertools.join\n.\n\n\n\n\nlist(sortedjoin(\n\n    \n[\n   \n-\n1\n,\n \n-\n1\n,\n \n-\n2\n,\n    \n-\n4\n,\n \n-\n5\n,\n    \n-\n6\n],\n\n    \n[\n0\n,\n  \n1\n,\n  \n1\n,\n  \n2\n,\n \n3\n,\n  \n4\n,\n  \n5\n,\n \n5\n],\n\n    \nleftkey\n=\nabs,\n \nleftdefault\n=\nNone\n\n\n))\n\n\n# [(None, 0),\n\n\n#  (-1, 1),\n\n\n#  (-1, 1),\n\n\n#  (-1, 1),\n\n\n#  (-1, 1),\n\n\n#  (-2, 2),\n\n\n#  (None, 3),\n\n\n#  (-4, 4),\n\n\n#  (-5, 5),\n\n\n#  (-5, 5)]",
            "title": "sortedtools"
        },
        {
            "location": "/functions/sortedtools/#sequence-check",
            "text": "",
            "title": "Sequence Check"
        },
        {
            "location": "/functions/sortedtools/#issorted",
            "text": "issorted(seq, key=None)  returns if sequence  seq  is already sorted, optionally according to the key function  key .  issorted([ 1 ,   2 ,   2 ,   3 ])  # True",
            "title": "issorted"
        },
        {
            "location": "/functions/sortedtools/#sequence-matching",
            "text": "Tools for matching sorted sequences.",
            "title": "Sequence Matching"
        },
        {
            "location": "/functions/sortedtools/#sortedcommon",
            "text": "sortedcommon(a, b, key=None)  returns the common elements between  a  and  b , optionally according to the key function  key .   Success  When both  a  and  b  are sorted sets with no duplicate element, equal to  sorted(set(a) & set(b))  but more efficient.   list(sortedcommon( \n     [ 1 ,   2 ,   2 ,   3 ], \n     [     2 ,      3 ,   4 ,   4 ]  ))  # [2, 3]",
            "title": "sortedcommon"
        },
        {
            "location": "/functions/sortedtools/#sortedalone",
            "text": "sortedalone(a, b, key=None)  returns the elements not in both  a  and  b , optionally according to the key function  key .   Success  When both  a  and  b  are sorted sets with no duplicate element, equal to  sorted((set(a) | set(b)) - (set(a) & set(b)))  but more efficient.   list(sortedalone( \n     [ 1 ,   2 ,   2 ,   3 ], \n     [     2 ,      3 ,   4 ,   4 ]  ))  # [1, 2, 4, 4]",
            "title": "sortedalone"
        },
        {
            "location": "/functions/sortedtools/#sorteddiff",
            "text": "sorteddiff(a, b, key=None)  returns the elements only in  a  and not in  b , optionally according to the key function  key .   Success  When both  a  and  b  are sorted sets with no duplicate element, equal to  sorted(set(a) - set(b))  but more efficient.   list(sorteddiff( \n     [ 1 ,   2 ,   2 ,   3 ], \n     [     2 ,      3 ,   4 ,   4 ]  ))  # [1, 2]",
            "title": "sorteddiff"
        },
        {
            "location": "/functions/sortedtools/#issubsorted",
            "text": "issubsorted(a, b, key=None)  checks if  a  is a sorted sub-sequence of  b , optionally according to the key function  key .   When both  a  and  b  are sorted sets with no duplicate element, equal to  set(a) <= set(b)  but more efficient.   issubsorted( \n     [ 1 ,   2 ,   2 ,   3 ], \n     [ 1 ,   2 ,   2 ,   3 ,   4 ,   4 ]  )  # True",
            "title": "issubsorted"
        },
        {
            "location": "/functions/sortedtools/#matchingfrequencies",
            "text": "matchingfrequencies(*seqs, key=None)  returns each item and the respective number of sequences in  seqs  contains it.   Optional key function  key  can be specified.    Success  This implementation is space efficient. If there are  n  sequences, only  O(n)  space is used.  sortedtools.matchingfrequencies  is more efficient than  seqtools.matchingfrequencies .    Tip  For the frequency of each item within a single sequence, use  toolz.itertoolz.frequencies .   list(matchingfrequencies( \n     [ 1 ,   2 ,   2 ,   3 ], \n     [     2 ,      3 ,      4 ,   5 ], \n     [ 1 ,         3 ,   3 ,   4 ]  ))  # [(1, 2), (2, 2), (3, 3), (4, 2), (5, 1)]",
            "title": "matchingfrequencies"
        },
        {
            "location": "/functions/sortedtools/#sequence-alignment-and-join",
            "text": "Tools for aligning and joining sorted sequences.",
            "title": "Sequence Alignment and Join"
        },
        {
            "location": "/functions/sortedtools/#sortedmatch",
            "text": "sortedmatch(a, b, default=None)  matches two sorted sequences  a  and  b  in pairs, such that the total number of matching pairs is maximized.   If there are multiple alignments having the same number, the leftmost one is returned.    Success  sortedmatch  is more efficient than  seqtools.match .   list(sortedmatch( \n     [ 1 ,   2 ,   2 ,   3 ], \n     [     2 ,      3 ,   4 ,   4 ]  ))  # [(1, None),  #  (2, 2),  #  (2, None),  #  (3, 3),  #  (None, 4),  #  (None, 4)]",
            "title": "sortedmatch"
        },
        {
            "location": "/functions/sortedtools/#sortedjoin",
            "text": "sortedjoin(leftseq, rightseq, leftkey=None, rightkey=None, leftdefault=no_default, rightdefault=no_default)  joins two sequences, optionally according to  leftkey  and  rightkey , respectively. Outer join is also supported.   Two sequences must be already sorted according to  leftkey  and  rightkey , respectively.    Success  sortedjoin  is more efficient than  seqtools.join  and its underneath  toolz.itertools.join .   list(sortedjoin( \n     [     - 1 ,   - 1 ,   - 2 ,      - 4 ,   - 5 ,      - 6 ], \n     [ 0 ,    1 ,    1 ,    2 ,   3 ,    4 ,    5 ,   5 ], \n     leftkey = abs,   leftdefault = None  ))  # [(None, 0),  #  (-1, 1),  #  (-1, 1),  #  (-1, 1),  #  (-1, 1),  #  (-2, 2),  #  (None, 3),  #  (-4, 4),  #  (-5, 5),  #  (-5, 5)]",
            "title": "sortedjoin"
        },
        {
            "location": "/functions/stattools/",
            "text": "Source\n\n\nStatistics\n\u00b6\n\n\nTools for statistics.\n\n\nmedianabsdev\n\u00b6\n\n\nmedianabsdev(data)\n computes the \nmedian absolute deviation\n of a sequence of floats.\n\n\nentropy\n\u00b6\n\n\nentropy(data)\n computes the \nentropy\n of a sequence of any items.\n\n\n\n\nTip\n\n\nYou can also pass a dictionary of \n(item, frequency)\n as known frequency distribution to \ndata\n.\n\n\n\n\nBinary Classification\n\u00b6\n\n\nTools for binary classification.\n\n\nteststats\n\u00b6\n\n\nteststats(truths, predictions)\n matches the truth labels and the prediction labels. Return a tuples of \n(tp, fp, tn, fn)\n as \ntrue positive, false positive, true negative, and false negative\n.\n\n\naccuracy\n\u00b6\n\n\naccuracy(tp, fp, tn, fn)\n returns the \naccuracy\n.\n\n\n\n\nTip\n\n\nYou can simply call \naccuracy(*teststats(truths, predictions))\n.\n\n\n\n\nprecision\n, \nrecall\n, and \nf1\n\u00b6\n\n\nprecision(tp, fp, tn, fn)\n and \nrecall(tp, fp, tn, fn)\n return the \nprecision and recall\n.\n\n\nf1(tp, fp, tn, fn, beta=1)\n returns the \nF\n_1\n measure\n in default, and returns the F\n_\\beta\n measure when \nbeta\n is specified.",
            "title": "stattools"
        },
        {
            "location": "/functions/stattools/#statistics",
            "text": "Tools for statistics.",
            "title": "Statistics"
        },
        {
            "location": "/functions/stattools/#medianabsdev",
            "text": "medianabsdev(data)  computes the  median absolute deviation  of a sequence of floats.",
            "title": "medianabsdev"
        },
        {
            "location": "/functions/stattools/#entropy",
            "text": "entropy(data)  computes the  entropy  of a sequence of any items.   Tip  You can also pass a dictionary of  (item, frequency)  as known frequency distribution to  data .",
            "title": "entropy"
        },
        {
            "location": "/functions/stattools/#binary-classification",
            "text": "Tools for binary classification.",
            "title": "Binary Classification"
        },
        {
            "location": "/functions/stattools/#teststats",
            "text": "teststats(truths, predictions)  matches the truth labels and the prediction labels. Return a tuples of  (tp, fp, tn, fn)  as  true positive, false positive, true negative, and false negative .",
            "title": "teststats"
        },
        {
            "location": "/functions/stattools/#accuracy",
            "text": "accuracy(tp, fp, tn, fn)  returns the  accuracy .   Tip  You can simply call  accuracy(*teststats(truths, predictions)) .",
            "title": "accuracy"
        },
        {
            "location": "/functions/stattools/#precision-recall-and-f1",
            "text": "precision(tp, fp, tn, fn)  and  recall(tp, fp, tn, fn)  return the  precision and recall .  f1(tp, fp, tn, fn, beta=1)  returns the  F _1  measure  in default, and returns the F _\\beta  measure when  beta  is specified.",
            "title": "precision, recall, and f1"
        },
        {
            "location": "/functions/strtools/",
            "text": "Source\n\n\n\n\nInfo\n\n\nTools in \nseqtools\n can also be applied here. \nstrtools\n only contains tools that are unique to the concept of string.\n\n\n\n\nString Matching\n\u00b6\n\n\nTools for string matching.\n\n\ncommonsubstr\n\u00b6\n\n\ncommonsubstr(a, b)\n finds the \nlongest common sub-string\n among two strings \na\n and \nb\n.\n\n\ncommonsubstr(\n\n     \n\"abbab\"\n,\n\n    \n\"aabbb\"\n\n\n)\n\n\n# \"abb\"\n\n\n\n\n\n\neditdist\n\u00b6\n\n\neditdist(a, b, bound=inf)\n computes the \nedit distance\n between two strings \na\n and \nb\n.\n\n\n\n\nTo speedup the computation, a threshold of maximum cost \nbound=inf\n can be specified. When there is no satisfying result, \nNone\n is returned.\n\n\n\n\neditdist(\n\n     \n\"dog\"\n,\n\n    \n\"frog\"\n\n\n)\n\n\n# 2\n\n\n\n\n\n\ntagstats\n\u00b6\n\n\ntagstats(tags, lines, separator=None)\n efficiently computes the number of lines containing each tag.\n\n\n\n\nseparator\n is a regex to tokenize each string. In default when \nseparator\n is \nNone\n, each string is not tokenized.\n\n\n\n\n\n\nSuccess\n\n\nTagStats\n is used to compute efficiently, where the common prefixes among tags are matched only once.\n\n\n\n\ntagstats(\n\n    \n[\n\"a b\"\n,\n \n\"a c\"\n,\n \n\"b c\"\n],\n\n    \n[\n\"a b c\"\n,\n \n\"b c d\"\n,\n \n\"c d e\"\n]\n\n\n)\n\n\n# {'a b': 1, 'a c': 0, 'b c': 2}\n\n\n\n\n\n\nextract\n\u00b6\n\n\nextract(s, entities, useregex=False, ignorecase=True)\n extracts the entities defined in \nentities\n from string \ns\n.\n\n\n\n\n\n\nRegular expression can be used to define each entity by specifying \nuseregex = True\n.\n\n\n\n\n\n\nignorecase=True\n specifies whether to ignore case when matching.\n\n\n\n\n\n\n\n\nTip\n\n\nCompatible third party library \nregex\n is used instead of standard library \nre\n, to support advanced unicode features.\n\n\n\n\n# From Python Documentation\n\n\ns\n \n=\n \n\"\"\"\n\n\nBoth patterns and strings to be searched can be Unicode strings (str) as well as 8-bit strings (bytes). \n\n\nHowever, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a byte pattern or vice-versa;\n\n\nsimilarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string.\n\n\n\"\"\"\n\n\n\nprint\n(set(extract(s,\n \n[\n\"str\"\n,\n \n\"byte\"\n,\n \n\"unicode\"\n,\n \n\"pattern\"\n])))\n\n\n# {'Unicode', 'str', 'pattern', 'byte'}\n\n\n\nprint\n(set(extract(s,\n \n[\n\"str\"\n,\n \n\"bytes?\"\n,\n \n\"unicode\"\n,\n \n\"patterns?\"\n],\n \nuseregex\n=\nTrue)))\n\n\n# {'str', 'bytes', 'patterns', 'Unicode', 'pattern', 'byte'}\n\n\n\n\n\n\nString Transformation\n\u00b6\n\n\nTools for string transformations.\n\n\nrewrite\n\u00b6\n\n\nrewrite(s, regex, template)\n rewrites a string \ns\n according to the template \ntemplate\n, where the values are extracted according to the regular expression \nregex\n.\n\n\n\n\nTip\n\n\nCheck \nre\n for details of naming capturing group.\n\n\nCheck \nstr.format\n for details of referring captured values in template.\n\n\n\n\nrewrite(\n\n    \n\"Elisa likes icecream.\"\n,\n\n    \nr\"(\\w+) likes (\\w+).\"\n,\n\n    \n\"{1} is {0}'s favorite.\"\n\n\n)\n\n\n# \"icecream is Elisa's favorite.\"\n\n\n\nrewrite(\n\n    \n\"Elisa likes icecream.\"\n,\n\n    \nr\"(?P<name>\\w+) likes (?P<item>\\w+).\"\n,\n\n    \n\"{item} is {name}'s favorite.\"\n\n\n)\n\n\n# \"icecream is Elisa's favorite.\"\n\n\n\n\n\n\nlearnrewrite\n\u00b6\n\n\nlearnrewrite(src, dst, minlen=3)\n learns the respective regular expression and template to rewrite \nsrc\n to \ndst\n.\n\n\n\n\n\n\nPlease check \nrewrite\n for details of the regular expression and template.\n\n\n\n\n\n\nminlen=3\n specifies the minimum length for each substitution.\n\n\n\n\n\n\n\n\nWarning\n\n\nAs regular expression is greedy, it cannot learn capturing groups next to each other.\n\n\n\n\nlearnrewrite(\n\n    \n\"Elisa likes icecream.\"\n,\n\n    \n\"icecream is Elisa's favorite.\"\n\n\n)\n\n\n# ('(.*) likes (.*).',\n\n\n#  \"{1} is {0}'s favorite.\")\n\n\n\nrewrite(\n\n    \n\"Elisa likes icecream.\"\n,\n\n    \n*\nlearnrewrite(\n\n        \n\"Elisa likes icecream.\"\n,\n\n        \n\"icecream is Elisa's favorite.\"\n\n    \n)\n\n\n)\n\n\n# \"icecream is Elisa's favorite.\"\n\n\n\n\n\n\nString Modeling\n\u00b6\n\n\nTools for modeling strings.\n\n\nstr2grams\n\u00b6\n\n\nstr2grams(s, n, pad='')\n returns the ordered \nn\n-grams\n of string \ns\n.\n\n\n\n\nOptional padding at the start and end can be added by specifying \npad\n.\n\n\n\n\n\n\nTip\n\n\n\\0\n is usually a safe choice for \npad\n when not displaying.\n\n\n\n\nlist(str2grams(\n\"str2grams\"\n,\n \n2\n,\n \npad\n=\n'#'\n))\n\n\n# ['#s', 'st', 'tr', 'r2', '2g', 'gr', 'ra', 'am', 'ms', 's#']\n\n\n\n\n\n\nChecksum\n\u00b6\n\n\nTools for checksums.\n\n\nsha1sum\n , \nsha256sum\n, \nsha512sum\n, and \nmd5sum\n\u00b6\n\n\nsha1sum(f)\n , \nsha256sum(f)\n, \nsha512sum(f)\n, and \nmd5sum(f)\n compute the respective checksum, accepting string, bytes, text file object, and binary file object.\n\n\nsha1sum(\n\"strtools\"\n)\n\n\n# 'bb91c4c3457cd1442acda4c11b29b02748679409'",
            "title": "strtools"
        },
        {
            "location": "/functions/strtools/#string-matching",
            "text": "Tools for string matching.",
            "title": "String Matching"
        },
        {
            "location": "/functions/strtools/#commonsubstr",
            "text": "commonsubstr(a, b)  finds the  longest common sub-string  among two strings  a  and  b .  commonsubstr( \n      \"abbab\" , \n     \"aabbb\"  )  # \"abb\"",
            "title": "commonsubstr"
        },
        {
            "location": "/functions/strtools/#editdist",
            "text": "editdist(a, b, bound=inf)  computes the  edit distance  between two strings  a  and  b .   To speedup the computation, a threshold of maximum cost  bound=inf  can be specified. When there is no satisfying result,  None  is returned.   editdist( \n      \"dog\" , \n     \"frog\"  )  # 2",
            "title": "editdist"
        },
        {
            "location": "/functions/strtools/#tagstats",
            "text": "tagstats(tags, lines, separator=None)  efficiently computes the number of lines containing each tag.   separator  is a regex to tokenize each string. In default when  separator  is  None , each string is not tokenized.    Success  TagStats  is used to compute efficiently, where the common prefixes among tags are matched only once.   tagstats( \n     [ \"a b\" ,   \"a c\" ,   \"b c\" ], \n     [ \"a b c\" ,   \"b c d\" ,   \"c d e\" ]  )  # {'a b': 1, 'a c': 0, 'b c': 2}",
            "title": "tagstats"
        },
        {
            "location": "/functions/strtools/#extract",
            "text": "extract(s, entities, useregex=False, ignorecase=True)  extracts the entities defined in  entities  from string  s .    Regular expression can be used to define each entity by specifying  useregex = True .    ignorecase=True  specifies whether to ignore case when matching.     Tip  Compatible third party library  regex  is used instead of standard library  re , to support advanced unicode features.   # From Python Documentation  s   =   \"\"\"  Both patterns and strings to be searched can be Unicode strings (str) as well as 8-bit strings (bytes).   However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a byte pattern or vice-versa;  similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string.  \"\"\"  print (set(extract(s,   [ \"str\" ,   \"byte\" ,   \"unicode\" ,   \"pattern\" ])))  # {'Unicode', 'str', 'pattern', 'byte'}  print (set(extract(s,   [ \"str\" ,   \"bytes?\" ,   \"unicode\" ,   \"patterns?\" ],   useregex = True)))  # {'str', 'bytes', 'patterns', 'Unicode', 'pattern', 'byte'}",
            "title": "extract"
        },
        {
            "location": "/functions/strtools/#string-transformation",
            "text": "Tools for string transformations.",
            "title": "String Transformation"
        },
        {
            "location": "/functions/strtools/#rewrite",
            "text": "rewrite(s, regex, template)  rewrites a string  s  according to the template  template , where the values are extracted according to the regular expression  regex .   Tip  Check  re  for details of naming capturing group.  Check  str.format  for details of referring captured values in template.   rewrite( \n     \"Elisa likes icecream.\" , \n     r\"(\\w+) likes (\\w+).\" , \n     \"{1} is {0}'s favorite.\"  )  # \"icecream is Elisa's favorite.\"  rewrite( \n     \"Elisa likes icecream.\" , \n     r\"(?P<name>\\w+) likes (?P<item>\\w+).\" , \n     \"{item} is {name}'s favorite.\"  )  # \"icecream is Elisa's favorite.\"",
            "title": "rewrite"
        },
        {
            "location": "/functions/strtools/#learnrewrite",
            "text": "learnrewrite(src, dst, minlen=3)  learns the respective regular expression and template to rewrite  src  to  dst .    Please check  rewrite  for details of the regular expression and template.    minlen=3  specifies the minimum length for each substitution.     Warning  As regular expression is greedy, it cannot learn capturing groups next to each other.   learnrewrite( \n     \"Elisa likes icecream.\" , \n     \"icecream is Elisa's favorite.\"  )  # ('(.*) likes (.*).',  #  \"{1} is {0}'s favorite.\")  rewrite( \n     \"Elisa likes icecream.\" , \n     * learnrewrite( \n         \"Elisa likes icecream.\" , \n         \"icecream is Elisa's favorite.\" \n     )  )  # \"icecream is Elisa's favorite.\"",
            "title": "learnrewrite"
        },
        {
            "location": "/functions/strtools/#string-modeling",
            "text": "Tools for modeling strings.",
            "title": "String Modeling"
        },
        {
            "location": "/functions/strtools/#str2grams",
            "text": "str2grams(s, n, pad='')  returns the ordered  n -grams  of string  s .   Optional padding at the start and end can be added by specifying  pad .    Tip  \\0  is usually a safe choice for  pad  when not displaying.   list(str2grams( \"str2grams\" ,   2 ,   pad = '#' ))  # ['#s', 'st', 'tr', 'r2', '2g', 'gr', 'ra', 'am', 'ms', 's#']",
            "title": "str2grams"
        },
        {
            "location": "/functions/strtools/#checksum",
            "text": "Tools for checksums.",
            "title": "Checksum"
        },
        {
            "location": "/functions/strtools/#sha1sum-sha256sum-sha512sum-and-md5sum",
            "text": "sha1sum(f)  ,  sha256sum(f) ,  sha512sum(f) , and  md5sum(f)  compute the respective checksum, accepting string, bytes, text file object, and binary file object.  sha1sum( \"strtools\" )  # 'bb91c4c3457cd1442acda4c11b29b02748679409'",
            "title": "sha1sum , sha256sum, sha512sum, and md5sum"
        },
        {
            "location": "/functions/tabletools/",
            "text": "Source\n\n\nTable Transformation\n\u00b6\n\n\nTools for table transformations.\n\n\ntranspose\n\u00b6\n\n\ntranspose(data)\n returns the transpose of table \ndata\n, i.e., switch rows and columns.\n\n\n\n\nTip\n\n\nUseful to switch table \ndata\n from row-based to column-based and backwards.\n\n\n\n\nlist(transpose([\n\n    \n[\n1\n,\n \n2\n,\n \n3\n],\n\n    \n[\n4\n,\n \n5\n,\n \n6\n],\n\n    \n[\n7\n,\n \n8\n,\n \n9\n]\n\n\n]))\n\n\n# [[1, 4, 7],\n\n\n#  [2, 5, 8],\n\n\n#  [3, 6, 9]]\n\n\n\n\n\n\nmergecols\n\u00b6\n\n\nmergecols(cols, default=None, blank=None)\n merges the columns in \ncols\n into a single column. Returns \nNone\n if there is conflict in any row.\n\n\n\n\n\n\nA row has conflict if there are more than one valid values, where each valid value is not \nNone\n or empty.\n\n\n\n\nblank=None\n is a list of characters denoting empty value. Default to whitespace characters.\n\n\n\n\n\n\n\n\ndefault\n is a placeholder when there are no valid value in one row.\n\n\n\n\n\n\n\n\nTip\n\n\nCheck the builtin function \nstr.strip\n for details of the behavior with \nblank\n.\n\n\n\n\ncols\n \n=\n \nlist(transpose([\n\n    \n[\n   \n0\n,\n \nNone,\n    \n2\n],\n\n    \n[\n   \n0\n,\n    \n1\n,\n \nNone],\n\n    \n[None,\n    \n1\n,\n \nNone]\n\n    \n[\n0\n,\n    \nNone,\n \nNone]\n\n\n]))\n\n\n\n# Merge the last two columns.\n\n\nmergecols(cols[\n1\n:])\n\n\n# [2,\n\n\n#  1,\n\n\n#  1,\n\n\n#  None]\n\n\n\n# Merge all three columns.\n\n\nmergecols(cols)\n\n\n# None\n\n\n\n\n\n\ntrim\n\u00b6\n\n\ntrim(table, blank=None\n) removes any empty column or row.\n\n\n\n\nblank=None\n is a list of characters denoting empty value. Default to whitespace characters.\n\n\n\n\n\n\nTip\n\n\nCheck the builtin function \nstr.strip\n for details of the behavior with \nblank\n.\n\n\n\n\nlist(trim([\n\n    \n[\n''\n,\n \n'a'\n,\n \n'b'\n],\n\n    \n[\n''\n,\n \n'-'\n,\n \n'-'\n],\n\n    \n[\n''\n,\n \n'c'\n,\n \n'd'\n]\n\n\n],\n \nblank\n=\n'-'\n))\n\n\n# [['a', 'b'],\n\n\n#  ['c', 'd']]\n\n\n\n\n\n\nCSV\n\u00b6\n\n\nTools for processing CSV.\n\n\nloadcsv\n\u00b6\n\n\nloadcsv(path, delimiter=',')\n loads a CSV file, from either a file path or a file object.\n\n\ndumpcsv\n\u00b6\n\n\ndumpcsv(path, data, delimiter=',')\n dumps a table \ndata\n in CSV, to either a file path or a file object.\n\n\nParsing Text to Table\n\u00b6\n\n\nTools for parsing each line of text to a row in respective table.\n\n\nparse\n\u00b6\n\n\nparse(lines, sep=None, useregex=False)\n parses each line to a row by using separator \nsep=None\n.\n\n\n\n\nIn default, \nsep\n is a plain string. When setting \nuseregex\n, \nsep\n is a regular expression for more advanced scenarios.\n\n\n\n\n\n\nTip\n\n\nCheck the builtin function \nstr.split\n for details of the behavior with \nsep\n when \nuseregex = False\n.\n\n\n\n\nlist(parse([\n\n    \n\"1 ALICE Pairs\"\n,\n\n    \n\"2 BOB London\"\n\n\n]))\n\n\n# [['1', 'ALICE',  'Pairs'],\n\n\n#  ['2',   'BOB', 'London']]\n\n\n\nlist(parse([\n\n    \n\"1 | ALICE | Pairs\"\n,\n\n    \n\"2 | BOB | London\"\n\n\n],\n \nsep\n=\nr\"\\s*\\|\\s*\"\n,\n \nuseregex\n=\nTrue))\n\n\n# [['1', 'ALICE',  'Pairs'],\n\n\n#  ['2',   'BOB', 'London']]\n\n\n\n\n\n\nparsebymarkdown\n\u00b6\n\n\nparsebymarkdown(text)\n parses a text of multiple lines to a table, according to \nMarkdown\n format.\n\n\nlist(parseasmarkdown(\n\"\"\"\n\n\n| foo | bar |\n\n\n| --- | --- |\n\n\n| baz | bim |\n\n\n\"\"\"\n))\n\n\n# [['foo', 'bar'],\n\n\n#  ['baz', 'bim']]\n\n\n\n\n\n\nparsebyregex\n\u00b6\n\n\nparsebyregex(lines, regex)\n parses each line to a row by using a regular expression \nregex\n, where each capturing group matches a column value.\n\n\n\n\nregex\n can be either a regular expression string, or a regular expression object (compiled by either \nre\n or \nregex\n) for more advanced usage.\n\n\n\n\n\n\nTip\n\n\nCompatible third party library \nregex\n is used instead of standard library \nre\n, to support advanced unicode features.\n\n\n\n\nlist(parsebyregex(\n\n    \n[\n\n        \n\"1 ALICE Pairs\"\n,\n\n        \n\"2 BOB London\"\n,\n\n        \n\"3 CARL JR New York\"\n\n    \n],\n\n    \nr\"\\s+\"\n.\njoin([\n\n        \nr\"(\\d+)\"\n,\n\n        \nr\"([A-Z]+(?:\\s+[A-Z]+)*)\"\n,\n\n        \nr\"(.+)\"\n\n    \n])\n\n\n))\n\n\n# [('1',   'ALICE',    'Pairs'),\n\n\n#  ('2',     'BOB',   'London'),\n\n\n#  ('3', 'CARL JR', 'New York')]\n\n\n\n\n\n\nparsebyregexes\n\u00b6\n\n\nparsebyregexes(lines, regexes)\n parses each line to a row by using a list of regular expressions \nregexes\n, where each regular expression matches a column value.\n\n\n\n\nEach regular expression of \nregexes\n can be either a regular expression string, or a regular expression object (compiled by either \nre\n or \nregex\n) for more advanced usage.\n\n\n\n\n\n\nTip\n\n\nCompatible third party library \nregex\n is used instead of standard library \nre\n, to support advanced unicode features.\n\n\n\n\nlist(parsebyregexes(\n\n    \n[\n\n        \n\"1 ALICE Pairs\"\n,\n\n        \n\"2 BOB London\"\n,\n\n        \n\"3 CARL JR New York\"\n\n    \n],\n\n    \n[\n\n        \nr\"\\b\\d\\b\"\n,\n\n        \nr\"\\b[A-Z]+(?:\\s+[A-Z]+)*\\b\"\n,\n\n        \nr\"\\b\\S.+\\b\"\n\n    \n]\n\n\n))\n\n\n# [['1',   'ALICE',    'Pairs'],\n\n\n#  ['2',     'BOB',   'London'],\n\n\n#  ['3', 'CARL JR', 'New York']]",
            "title": "tabletools"
        },
        {
            "location": "/functions/tabletools/#table-transformation",
            "text": "Tools for table transformations.",
            "title": "Table Transformation"
        },
        {
            "location": "/functions/tabletools/#transpose",
            "text": "transpose(data)  returns the transpose of table  data , i.e., switch rows and columns.   Tip  Useful to switch table  data  from row-based to column-based and backwards.   list(transpose([ \n     [ 1 ,   2 ,   3 ], \n     [ 4 ,   5 ,   6 ], \n     [ 7 ,   8 ,   9 ]  ]))  # [[1, 4, 7],  #  [2, 5, 8],  #  [3, 6, 9]]",
            "title": "transpose"
        },
        {
            "location": "/functions/tabletools/#mergecols",
            "text": "mergecols(cols, default=None, blank=None)  merges the columns in  cols  into a single column. Returns  None  if there is conflict in any row.    A row has conflict if there are more than one valid values, where each valid value is not  None  or empty.   blank=None  is a list of characters denoting empty value. Default to whitespace characters.     default  is a placeholder when there are no valid value in one row.     Tip  Check the builtin function  str.strip  for details of the behavior with  blank .   cols   =   list(transpose([ \n     [     0 ,   None,      2 ], \n     [     0 ,      1 ,   None], \n     [None,      1 ,   None] \n     [ 0 ,      None,   None]  ]))  # Merge the last two columns.  mergecols(cols[ 1 :])  # [2,  #  1,  #  1,  #  None]  # Merge all three columns.  mergecols(cols)  # None",
            "title": "mergecols"
        },
        {
            "location": "/functions/tabletools/#trim",
            "text": "trim(table, blank=None ) removes any empty column or row.   blank=None  is a list of characters denoting empty value. Default to whitespace characters.    Tip  Check the builtin function  str.strip  for details of the behavior with  blank .   list(trim([ \n     [ '' ,   'a' ,   'b' ], \n     [ '' ,   '-' ,   '-' ], \n     [ '' ,   'c' ,   'd' ]  ],   blank = '-' ))  # [['a', 'b'],  #  ['c', 'd']]",
            "title": "trim"
        },
        {
            "location": "/functions/tabletools/#csv",
            "text": "Tools for processing CSV.",
            "title": "CSV"
        },
        {
            "location": "/functions/tabletools/#loadcsv",
            "text": "loadcsv(path, delimiter=',')  loads a CSV file, from either a file path or a file object.",
            "title": "loadcsv"
        },
        {
            "location": "/functions/tabletools/#dumpcsv",
            "text": "dumpcsv(path, data, delimiter=',')  dumps a table  data  in CSV, to either a file path or a file object.",
            "title": "dumpcsv"
        },
        {
            "location": "/functions/tabletools/#parsing-text-to-table",
            "text": "Tools for parsing each line of text to a row in respective table.",
            "title": "Parsing Text to Table"
        },
        {
            "location": "/functions/tabletools/#parse",
            "text": "parse(lines, sep=None, useregex=False)  parses each line to a row by using separator  sep=None .   In default,  sep  is a plain string. When setting  useregex ,  sep  is a regular expression for more advanced scenarios.    Tip  Check the builtin function  str.split  for details of the behavior with  sep  when  useregex = False .   list(parse([ \n     \"1 ALICE Pairs\" , \n     \"2 BOB London\"  ]))  # [['1', 'ALICE',  'Pairs'],  #  ['2',   'BOB', 'London']]  list(parse([ \n     \"1 | ALICE | Pairs\" , \n     \"2 | BOB | London\"  ],   sep = r\"\\s*\\|\\s*\" ,   useregex = True))  # [['1', 'ALICE',  'Pairs'],  #  ['2',   'BOB', 'London']]",
            "title": "parse"
        },
        {
            "location": "/functions/tabletools/#parsebymarkdown",
            "text": "parsebymarkdown(text)  parses a text of multiple lines to a table, according to  Markdown  format.  list(parseasmarkdown( \"\"\"  | foo | bar |  | --- | --- |  | baz | bim |  \"\"\" ))  # [['foo', 'bar'],  #  ['baz', 'bim']]",
            "title": "parsebymarkdown"
        },
        {
            "location": "/functions/tabletools/#parsebyregex",
            "text": "parsebyregex(lines, regex)  parses each line to a row by using a regular expression  regex , where each capturing group matches a column value.   regex  can be either a regular expression string, or a regular expression object (compiled by either  re  or  regex ) for more advanced usage.    Tip  Compatible third party library  regex  is used instead of standard library  re , to support advanced unicode features.   list(parsebyregex( \n     [ \n         \"1 ALICE Pairs\" , \n         \"2 BOB London\" , \n         \"3 CARL JR New York\" \n     ], \n     r\"\\s+\" . join([ \n         r\"(\\d+)\" , \n         r\"([A-Z]+(?:\\s+[A-Z]+)*)\" , \n         r\"(.+)\" \n     ])  ))  # [('1',   'ALICE',    'Pairs'),  #  ('2',     'BOB',   'London'),  #  ('3', 'CARL JR', 'New York')]",
            "title": "parsebyregex"
        },
        {
            "location": "/functions/tabletools/#parsebyregexes",
            "text": "parsebyregexes(lines, regexes)  parses each line to a row by using a list of regular expressions  regexes , where each regular expression matches a column value.   Each regular expression of  regexes  can be either a regular expression string, or a regular expression object (compiled by either  re  or  regex ) for more advanced usage.    Tip  Compatible third party library  regex  is used instead of standard library  re , to support advanced unicode features.   list(parsebyregexes( \n     [ \n         \"1 ALICE Pairs\" , \n         \"2 BOB London\" , \n         \"3 CARL JR New York\" \n     ], \n     [ \n         r\"\\b\\d\\b\" , \n         r\"\\b[A-Z]+(?:\\s+[A-Z]+)*\\b\" , \n         r\"\\b\\S.+\\b\" \n     ]  ))  # [['1',   'ALICE',    'Pairs'],  #  ['2',     'BOB',   'London'],  #  ['3', 'CARL JR', 'New York']]",
            "title": "parsebyregexes"
        },
        {
            "location": "/datastructures/defaultlist/",
            "text": "Source\n\n\nA sub-class of \nlist\n that automatically grows when setting an index beyond the list size.\n\n\n\n\nWhen creating a list, use \nDefaultList(default, ...)\n to specify a function that returns default value when visiting an unassigned index.\n\n\n\n\n\n\nTip\n\n\nThis library is designed to be highly similar to \ncollections.defaultdict\n in standard library.\n\n\n\n\nl\n \n=\n \nDefaultList(\nlambda\n:\n \nNone,\n \nrange(\n10\n))\n\n\n\nl[\n11\n]\n \n=\n \n11\n\n\n\nl\n\n\n# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, None, 11]",
            "title": "defaultlist.DefaultList"
        },
        {
            "location": "/datastructures/disjointsets/",
            "text": "Source\n\n\nDisjoint sets\n with path compression. After \nd = DisjointSets()\n:\n\n\n\n\n\n\nd.add(x)\n adds a new disjoint set containing \nx\n.\n\n\n\n\n\n\nd[x]\n returns the representing element of the disjoint set containing \nx\n.\n\n\n\n\n\n\nd.disjoints()\n returns all the representing elements and their respective disjoint sets.\n\n\n\n\n\n\nd.union(*xs)\n union all the elements in \nxs\n into a single disjoint set.\n\n\n\n\n\n\n\n\nNote\n\n\nBased a lot on this \nimplementation",
            "title": "disjointsets.DisjointSets"
        },
        {
            "location": "/datastructures/segmenttree/",
            "text": "Source\n\n\nThis data structure solves the \nrange minimum query problem\n of finding the minimal value in a sub-array of an array of comparable objects. Different from the original problem, this data structure also supports updating the values.\n\n\nInitialization\n\u00b6\n\n\nUse \nSegmentTree()\n to initialize the tree with a set of keys, in \ncomparable and hashable\n type.\n\n\n\n\n\n\nfunc=min\n specifies how the best value is computed for any range of keys.\n\n\n\n\n\n\ndefault=None\n specifies the default value for each key.\n\n\n\n\n\n\nmaxChildNum=2\n specifies the maximum number of children for each node.\n\n\n\n\n\n\n\n\nInfo\n\n\nThe space complexity should be \nO(n)\n.\n\n\n\n\ntree\n \n=\n \nSegmentTree(\n\n    \n{\n1\n,\n \n2\n,\n \n3\n,\n \n4\n,\n \n5\n},\n\n    \nfunc\n=\nmin,\n \ndefault\n=\n0\n,\n \nmaxChildNum\n=\n2\n\n\n)\n\n\n\n\n\n\nUpdating\n\u00b6\n\n\nYou need to use \nupdate()\n to initialize the values, or update the values if necessary, by specifying a dictionary of key/value pairs. Currently, adding new keys is not supported yet.\n\n\n\n\nInfo\n\n\nGiven m values updated, the time complexity should be \nO(m^2)\n.\n\n\n\n\ntree\n.\nupdate({\n1\n:\n \n3\n,\n \n4\n:\n \n6\n})\n\n\n\n\n\n\nQuerying\n\u00b6\n\n\nUse \nquery()\n to to find the best value of a range of keys. The range is denoted by a tuple \n(a, b)\n, representing each key \nx\n such that \na <= x < b\n. The range here is closed on the left side and open on the right side, consistent with Python tradition.\n\n\n\n\nInfo\n\n\nThe time complexity should be \nO(log n)\n.\n\n\n\n\ntree\n.\nquery((\n1\n,\n \n3\n))",
            "title": "segmenttree.SegmentTree"
        },
        {
            "location": "/datastructures/segmenttree/#initialization",
            "text": "Use  SegmentTree()  to initialize the tree with a set of keys, in  comparable and hashable  type.    func=min  specifies how the best value is computed for any range of keys.    default=None  specifies the default value for each key.    maxChildNum=2  specifies the maximum number of children for each node.     Info  The space complexity should be  O(n) .   tree   =   SegmentTree( \n     { 1 ,   2 ,   3 ,   4 ,   5 }, \n     func = min,   default = 0 ,   maxChildNum = 2  )",
            "title": "Initialization"
        },
        {
            "location": "/datastructures/segmenttree/#updating",
            "text": "You need to use  update()  to initialize the values, or update the values if necessary, by specifying a dictionary of key/value pairs. Currently, adding new keys is not supported yet.   Info  Given m values updated, the time complexity should be  O(m^2) .   tree . update({ 1 :   3 ,   4 :   6 })",
            "title": "Updating"
        },
        {
            "location": "/datastructures/segmenttree/#querying",
            "text": "Use  query()  to to find the best value of a range of keys. The range is denoted by a tuple  (a, b) , representing each key  x  such that  a <= x < b . The range here is closed on the left side and open on the right side, consistent with Python tradition.   Info  The time complexity should be  O(log n) .   tree . query(( 1 ,   3 ))",
            "title": "Querying"
        },
        {
            "location": "/cli/",
            "text": "CLI Tools\n\u00b6\n\n\nPlease check each individual script for more details.\n\n\ndicttools.remap\n\u00b6\n\n\nSource\n\n\nUsage:\n    extratools-remap <mapping>\n\n\n\n\n\njsontools.flatten\n\u00b6\n\n\nSource\n\n\nUsage:\n    extratools-flatten [--force]\n\n\n\n\n\nstattools.teststats\n\u00b6\n\n\nSource\n\n\nUsage:\n    extratools-teststats <truth> <prediction>",
            "title": "CLI Tools"
        },
        {
            "location": "/cli/#cli-tools",
            "text": "Please check each individual script for more details.",
            "title": "CLI Tools"
        },
        {
            "location": "/cli/#dicttoolsremap",
            "text": "Source  Usage:\n    extratools-remap <mapping>",
            "title": "dicttools.remap"
        },
        {
            "location": "/cli/#jsontoolsflatten",
            "text": "Source  Usage:\n    extratools-flatten [--force]",
            "title": "jsontools.flatten"
        },
        {
            "location": "/cli/#stattoolsteststats",
            "text": "Source  Usage:\n    extratools-teststats <truth> <prediction>",
            "title": "stattools.teststats"
        }
    ]
}